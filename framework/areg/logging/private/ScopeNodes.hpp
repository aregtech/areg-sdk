#ifndef AREG_LOGGING_PRIVATE_SCOPENODES_HPP
#define AREG_LOGGING_PRIVATE_SCOPENODES_HPP
/************************************************************************
 * This file is part of the AREG SDK core engine.
 * AREG SDK is dual-licensed under Free open source (Apache version 2.0
 * License) and Commercial (with various pricing models) licenses, depending
 * on the nature of the project (commercial, research, academic or free).
 * You should have received a copy of the AREG SDK license description in LICENSE.txt.
 * If not, please contact to info[at]aregtech.com
 *
 * \copyright   (c) 2017-2023 Aregtech UG. All rights reserved.
 * \file        areg/logging/private/ScopeNodes.hpp
 * \ingroup     AREG SDK, Automated Real-time Event Grid Software Development Kit
 * \author      Artak Avetyan
 * \brief       AREG Platform, The scope nodes classes.
 ************************************************************************/
 /************************************************************************
  * Include files.
  ************************************************************************/
#include "areg/base/GEGlobal.h"
#include "areg/logging/private/ScopeNodeBase.hpp"

#include "areg/base/TESortedLinkedList.hpp"

#if AREG_LOGS
/************************************************************************
 * Implemented classes.
 ************************************************************************/
class ScopeLeaf;
class ScopeNode;
class ScopeRoot;
class ConfigManager;

//////////////////////////////////////////////////////////////////////////
// ScopeLeaf class declaration
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   The Leaf node, which has a parent, but does not have children nodes.
 **/
class ScopeLeaf : public ScopeNodeBase
{
//////////////////////////////////////////////////////////////////////////
// Constructors / destructor
//////////////////////////////////////////////////////////////////////////
public:
    ScopeLeaf( void );
    /**
     * \brief   Copies data from the ScopeNodeBase object. Should be called explicit.
     **/
    explicit ScopeLeaf( const ScopeNodeBase & base );

    /**
     * \brief   Copies or moves data from the given source
     **/
    ScopeLeaf( const ScopeLeaf & src );    
    ScopeLeaf( ScopeLeaf && src ) noexcept;

    virtual ~ScopeLeaf( void ) = default;

//////////////////////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////////////////////
public:

    /**
     * \brief   Assigns data from the given source. Default implementation
     **/
    ScopeLeaf & operator = ( const ScopeLeaf & src ) = default;
    ScopeLeaf & operator = ( ScopeLeaf && src ) = default;

//////////////////////////////////////////////////////////////////////////
// Overrides
//////////////////////////////////////////////////////////////////////////
public:

/************************************************************************
 * ScopeNodeBase override
 ************************************************************************/

    /**
     * \brief   Creates a scope name (scope path) by adding the prefix to the node name.
     *          If the node is a leaf, it just adds the name. If it is a node, it adds
     *          the name and '_' at the end to indicate the node.
     * \param   prefix  The prefix to add to the name. In case of root, it is an empty
     *                  sting. In case of nodes, it is a path generated by parent nodes.
     **/
    virtual String makeScopePath( const String & prefix ) const override;

    /**
     * \brief   Generates the scope setting and updates in the configuration.
     *          -   If the entry is a leaf, it generates the full scope name to save in configuration.
     *          -   If the entry is a node and it has a grouping flag, it generates the scope group to save in configuration.
     *          -   If the entry is the root and has no child entries, it generates application scope group entry to save in configuration.
     * \param   config      The instance of ConfigManager to set the scope and priorities to save.
     * \param   parentPath  The path name of the parent node. The nodes contain '_' at the end.
     * \return  Returns the number of nodes that have been saved.
     **/
    virtual unsigned int updateConfigNode( ConfigManager & config, const String & parentPath ) const override;

};

//////////////////////////////////////////////////////////////////////////
// ScopeNode class declaration
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   The scope node, which has parent, leafs and child nodes.
 **/
class ScopeNode : public ScopeNodeBase
{
//////////////////////////////////////////////////////////////////////////
// Internal types
//////////////////////////////////////////////////////////////////////////
public:
    using NodeList = TESortedLinkedList< ScopeNode>;
    using LeafList = TESortedLinkedList< ScopeLeaf>;

//////////////////////////////////////////////////////////////////////////
// Constructors / Destructor
//////////////////////////////////////////////////////////////////////////
public:
    ScopeNode( void );

    /**
     * \brief   Creates a node with empty list of child leafs and nodes
     *          and copies data from the base object.
     **/
    explicit ScopeNode( const ScopeNodeBase & base );

    /**
     * \brief   Copies or moves data from the given source
     **/
    ScopeNode( const ScopeNode & src );    
    ScopeNode( ScopeNode && src ) noexcept;
    
    virtual ~ScopeNode( void ) = default;

//////////////////////////////////////////////////////////////////////////
// Protected constructor
//////////////////////////////////////////////////////////////////////////
protected:
    /**
     * \brief   Protected constructor required by root node.
     **/
    ScopeNode( ScopeNodeBase::eNode nodeType, const String & name, unsigned int prio );

//////////////////////////////////////////////////////////////////////////
// Assigning operators
//////////////////////////////////////////////////////////////////////////
public:
    /**
     * \brief   Copies data from the given source.
     **/
    ScopeNode & operator = ( const ScopeNode & src );
    ScopeNode & operator = ( ScopeNode && src ) noexcept;

//////////////////////////////////////////////////////////////////////////
// Override
//////////////////////////////////////////////////////////////////////////
public:

/************************************************************************
 * ScopeNodeBase override
 ************************************************************************/

 /**
  * \brief   Creates a child node out of scope name and sets the scope log priority flags.
  *          Whether it is a node or a leaf, depends on scope name. The last name in
  *          the scope is a leaf. All others are nodes.
  *          On output, the 'scopePath' with contain the remaining path or an empty string
  *          if a leaf was created.
  * \param   scopePath   The path of the scope to create a node. On output, this contains
  *                      either the remaining path or empty string if a leaf was created.
  * \param   prioStates  Bitwise logging priority set to scope.
  * \return  Returns created node. It is either a node or a leaf.
  * \note    Only the root and nodes can create nodes or leafs. The leafs return invalid node.
  **/
    virtual const ScopeNodeBase & makeChildNode( String & IN OUT scopePath, unsigned int prioStates ) const override;

    /**
     * \brief   Adds a child node to the node if it does not contain a child of the same type
     *          and same name. If it contains, only updates the log priority flag.
     *          Only root or nodes can contain child. This method is ignored in case of leaf.
     * \param   child   The child node to add or update.
     * \return  Returns a pair of new node entry in the child list and a boolean flag indicating whether
     *          it created new entry or updated the existing.
     **/
    virtual std::pair<ScopeNodeBase &, bool> addChildNode( const ScopeNodeBase & child ) override;

    /**
     * \brief   Creates a new node out of passed scope name and specified log priority.
     *          If there is node of the same type and same name, it updates the log priority.
     *          Otherwise, creates and inserts new entry. On output, the parameter 'scopePath'
     *          contains the remaining part of the scope after creating child node. It is empty
     *          when creates and adds a leaf.
     *          Only root or nodes can contain child. This method is ignored in case of leaf.
     * \param   scopePath   The name of the scope to generate a node. On output, this contains
     *                      the remaining part of the scope name.
     * \param   prioStates  Bitwise logging priority set to scope.
     * \return  Returns a pair of new node entry in the child list and a boolean flag indicating whether
     *          it created new entry or updated the existing.
     **/
    virtual std::pair<ScopeNodeBase &, bool> addChildNode( String & scopePath, unsigned int prioStates ) override;

    /**
     * \brief   Creates a scope name (scope path) by adding the prefix to the node name.
     *          If the node is a leaf, it just adds the name. If it is a node, it adds
     *          the name and '_' at the end to indicate the node.
     * \param   prefix  The prefix to add to the name. In case of root, it is an empty
     *                  sting. In case of nodes, it is a path generated by parent nodes.
     **/
    virtual String makeScopePath( const String & prefix ) const override;

    /**
     * \brief   Generates the scope configuration string with the logging
     *          priority setting to save in the file.
     * \param   parent  The parent scope name (or prefix) to add to generated name.
     * \return  Returns generated string, which contains the logging priority setting.
     **/
    virtual String makeConfigString( const String & parent ) const override;

    /**
     * \brief   Groups and removes child nodes if they have same log priority settings.
     *          It is grouping separately leafs and nodes. If leafs are grouped it as well
     *          removes all nodes with the same logging priority. If nodes are grouped, it
     *          removes all leafs with the same logging priority. When grouping, adds
     *          appropriate grouping flag, so that it generates the 'scope configuration setting'.
     *          Only the root and nodes can group child entries.
     * \return  Returns number of nodes that where removed.
     **/
    virtual unsigned int groupChildNodes( void ) override;

    /**
     * \brief   Generates the scope setting and updates in the configuration.
     *          -   If the entry is a leaf, it generates the full scope name to save in configuration.
     *          -   If the entry is a node and it has a grouping flag, it generates the scope group to save in configuration.
     *          -   If the entry is the root and has no child entries, it generates application scope group entry to save in configuration.
     * \param   config      The instance of ConfigManager to set the scope and priorities to save.
     * \param   parentPath  The path name of the parent node. The nodes contain '_' at the end.
     * \return  Returns the number of nodes that have been saved.
     **/
    virtual unsigned int updateConfigNode(ConfigManager& config, const String & parentPath ) const override;

    /**
     * \brief   Recursively groups child nodes. The grouping starts from the last node in the
     *          node tree to group leafs until the node that first triggered the method.
     *          Normally,the grouping starts from root node.
     * \return  Returns the number of nodes that it totally grouped.
     **/
    virtual unsigned int groupRecursive( void ) override;

    /**
     * \brief   Removes the priority nodes of specified log priority.
     *          It loops all child nodes and removes all entries that match
     *          the priority.
     * \return  Returns the number of nodes that are removed.
     **/
    virtual unsigned int removePriorityNodesRecursive( unsigned int prioRemove ) override;

    /**
     * \brief   Returns true if a node has no children nodes.
     **/
    virtual bool isEmpty( void ) const override;

//////////////////////////////////////////////////////////////////////////
// Attributes and operations
//////////////////////////////////////////////////////////////////////////
public:
    /**
     * \brief   Returns the list of child nodes.
     **/
    inline const ScopeNode::NodeList & getNodes( void ) const;

    /**
     * \brief   Returns the list of child leafs.
     **/
    inline const ScopeNode::LeafList & getLeafs( void ) const;

    /**
     * \brief   Returns the total number of children.
     **/
    inline unsigned int childNodeCount( void ) const;

//////////////////////////////////////////////////////////////////////////
// Protected members
//////////////////////////////////////////////////////////////////////////
protected:
    //!< The list of child nodes.
    NodeList    mChildNodes;

    //!< The list of child leafs.
    LeafList    mChildLeafs;
};

//////////////////////////////////////////////////////////////////////////
// ScopeRoot class declarations
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   The root node, which does not have a parent, but may have
 *          child nodes and child leafs.
 **/
class ScopeRoot : public ScopeNode
{
//////////////////////////////////////////////////////////////////////////
// Constructor / Destructor
//////////////////////////////////////////////////////////////////////////
public:
    ScopeRoot( void );

    virtual ~ScopeRoot( void ) = default;

//////////////////////////////////////////////////////////////////////////
// Override
//////////////////////////////////////////////////////////////////////////
public:

/************************************************************************
 * ScopeNodeBase override
 ************************************************************************/

    /**
     * \brief   Creates a scope name (scope path) by adding the prefix to the node name.
     *          If the node is a leaf, it just adds the name. If it is a node, it adds
     *          the name and '_' at the end to indicate the node.
     * \param   prefix  The prefix to add to the name. In case of root, it is an empty
     *                  sting. In case of nodes, it is a path generated by parent nodes.
     **/
    virtual String makeScopePath( const String & prefix ) const override;

    /**
     * \brief   Generates the scope configuration string with the logging
     *          priority setting to save in the file.
     * \param   parent  The parent scope name (or prefix) to add to generated name.
     * \return  Returns generated string, which contains the logging priority setting.
     **/
    virtual String makeConfigString( const String & parent ) const override;

    /**
     * \brief   Generates the scope setting and updates in the configuration.
     *          -   If the entry is a leaf, it generates the full scope name to save in configuration.
     *          -   If the entry is a node and it has a grouping flag, it generates the scope group to save in configuration.
     *          -   If the entry is the root and has no child entries, it generates application scope group entry to save in configuration.
     * \param   config      The instance of ConfigManager to set the scope and priorities to save.
     * \param   parentPath  The path name of the parent node. The nodes contain '_' at the end.
     * \return  Returns the number of nodes that have been saved.
     **/
    virtual unsigned int updateConfigNode(ConfigManager& config, const String & parentPath ) const override;

//////////////////////////////////////////////////////////////////////////
// Forbidden calls
//////////////////////////////////////////////////////////////////////////
private:
    DECLARE_NOCOPY_NOMOVE( ScopeRoot );
};

//////////////////////////////////////////////////////////////////////////
// ScopeNode class inline methods
//////////////////////////////////////////////////////////////////////////

inline const ScopeNode::NodeList & ScopeNode::getNodes( void ) const
{
    return mChildNodes;
}

inline const ScopeNode::LeafList & ScopeNode::getLeafs( void ) const
{
    return mChildLeafs;
}

inline unsigned int ScopeNode::childNodeCount( void ) const
{
    return (mChildLeafs.getSize( ) + mChildNodes.getSize( ));
}

#endif  // AREG_LOGS
#endif  // AREG_LOGGING_PRIVATE_SCOPENODES_HPP
