#ifndef AREG_BASE_NEUTILITIES_HPP
#define AREG_BASE_NEUTILITIES_HPP
/************************************************************************
 * This file is part of the AREG SDK core engine.
 * AREG SDK is dual-licensed under Free open source (Apache version 2.0
 * License) and Commercial (with various pricing models) licenses, depending
 * on the nature of the project (commercial, research, academic or free).
 * You should have received a copy of the AREG SDK license description in LICENSE.txt.
 * If not, please contact to info[at]aregtech.com
 *
 * \copyright   (c) 2017-2022 Aregtech UG. All rights reserved.
 * \file        areg/base/NEUtilities.hpp
 * \ingroup     AREG SDK, Asynchronous Event Generator Software Development Kit 
 * \author      Artak Avetyan
 * \brief       AREG Platform, Utilities
 *              Helper functions and constants.
 *
 ************************************************************************/
/************************************************************************
 * Include files.
 ************************************************************************/
#include "areg/base/GEGlobal.h"
#include "areg/base/NEMath.hpp"

#include <chrono>
#include <string_view>
#include <utility>

/************************************************************************
 * Dependencies
 ************************************************************************/
class String;
class IEInStream;
class IEOutStream;

struct tm;

//////////////////////////////////////////////////////////////////////////
// NEUtilities namespace declaration
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   Collection of helper functions and constants.
 *          For details see description of constants and functions.
 *
 **/
namespace   NEUtilities
{
/************************************************************************/
// NEUtilities namespace predefined constants
/************************************************************************/

    /**
     * \brief   NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE
     *          Constants. Predefined value, the maximum length of name
     *          generated by system.
     **/
    constexpr int                   MAX_GENERATED_NAME_BUFFER_SIZE  	{ 0xFF };

    /**
     * \brief   NEUtilities::DEFAULT_GENERATED_NAME
     *          Constant. Predefined default prefix for generated
     *          by system names.
     **/
    constexpr std::string_view      DEFAULT_GENERATED_NAME          	{ "Name" };
    /**
     * \brief   NEUtilities::ITEM_NAMES_MAX_LENGTH
     *          The maximum length of item names such as thread name, component or service names
     **/
    constexpr unsigned int          ITEM_NAMES_MAX_LENGTH           	{ 64 };

    /**
     * \brief   NEUtilities::WIN_TO_POSIX_EPOCH_BIAS_MICROSECS
     *          The difference in microseconds between Windows and Unix epoch.
     **/
    constexpr TIME64                WIN_TO_POSIX_EPOCH_BIAS_MICROSECS	{11644473600000000LL};

    /**
     * \brief   NEUtilities::SEC_TO_MILLISECS
     *          Milliseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_MILLISECS                    { 1'000LL };

    /**
     * \brief   NEUtilities::SEC_TO_MICROSECS
     *          Microseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_MICROSECS                    { 1'000'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_MICROSECS
     *          Microseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_MICROSECS               { 1'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_100NS
     *          100 nanoseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_100NS                   { 10'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_NS
     *          Nanoseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_NS                      { 1'000'000LL };

    /**
     * \brief   NEUtilities::SEC_TO_NS
     *          Nanoseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_NS                      		{ 1'000'000'000LL };

    /**
     * \brief   NEUtilities::MICROSEC_TO_100NS
     *          100-nanoseconds in 1 microsecond.
     **/
    constexpr TIME64                MICROSEC_TO_100NS                   { 10LL };

    /**
     * \brief   NEUtilities::MICROSEC_TO_NS
     *          Nanoseconds in 1 microsecond.
     **/
    constexpr TIME64                MICROSEC_TO_NS                    	{ 1'000LL };

/************************************************************************/
// NEUtilities namespace utility types
/************************************************************************/
    
    /**
     * \brief   NEUtilities::sSystemTime
     *          The structure defines date-time data used in system time
     **/
    typedef struct S_SystemTime
    {
        unsigned short  stYear;         //!< The year in the time
        unsigned short  stMonth;        //!< The month in the time, which starts from 1 (January) until 12 (December)
        unsigned short  stDayOfWeek;    //!< The day of week in the time, which starts from 0 (Sunday) until 6 (Saturday)
        unsigned short  stDay;          //!< The day of the month in the time, which starts from 1
        unsigned short  stHour;         //!< The hour in the time, which starts from 0
        unsigned short  stMinute;       //!< The minute in the time, which starts from 0
        unsigned short  stSecond;       //!< The second in the time, which starts from 0
        unsigned short  stMillisecs;    //!< The millisecond in the time, which starts from 0
        unsigned short  stMicrosecs;    //!< The microseconds in the time, which starts from 0
    } sSystemTime;

    /**
     * \brief   NEUtilities::sFileTime
     *          Specifies file time type and format.
     **/
    typedef struct S_FileTime
    {
        unsigned long   ftLowDateTime;  //!< Low part of date-time.
        unsigned long   ftHighDateTime; //!< High part of date-time.
    } sFileTime;

    /**
     * \brief   Returns current time. On output 'out_sysTime' system time contains the date-time data.
     * \param   sysTime     On output the system time parameter contains date-time of current time.
     * \param   localTime   If true, in output the out_sysTime contains local time values.
     **/
    AREG_API void systemTimeNow( sSystemTime & OUT sysTime, bool localTime );

    /**
     * \brief   Returns current time. On output 'out_fileTime' time contains the date-time data.
     * \param   fileTime    On output the file-time parameter contains date-time of current time.
     * \param   localTime   If true, in output the out_fileTime contains local time values.
     **/
    AREG_API void systemTimeNow( sFileTime & OUT fileTime, bool localTime );

    /**
     * \brief   Returns current system time data as a 64-bit integer value. The returned value is
     *          passed microseconds since January 1, 1970 (UNIX epoch).
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 systemTimeNow( void );

    /**
     * \brief   Returns system time data as a 64-bit integer value. The returned value is
     *          passed microseconds since January 1, 1970 (UNIX epoch).
     * \param   sysTime     The system time structure with data to convert.
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 convToTime( const sSystemTime & IN sysTime );

    /**
     * \brief   Returns file time data as a 64-bit integer value. The returned value is
     *          passed microseconds since January 1, 1970 (UNIX epoch).
     * \param   fileTime    The system time structure with data to convert.
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 convToTime( const sFileTime & IN fileTime );

    /**
     * \brief   Converts 64-bit value of microseconds passed since January 1 1970 into system time data structure.
     * \param   timeValue   64-bit value as microseconds passed since January 1 1970.
     * \param   sysTime     On output the system time parameter contains date-time of converted time.
     **/
    AREG_API void convToSystemTime( const TIME64 & IN timeValue, sSystemTime & OUT sysTime );

    /**
     * \brief   Converts given file-time data structure into system time data structure.
     * \param   fileTime        The file-time data structure to convert.
     * \param   out_sysTime     On output the system time parameter contains date-time of converted time.
     **/
    AREG_API void convToSystemTime( const sFileTime & fileTime, sSystemTime & out_sysTime );

    /**
     * \brief   Converts 64-bit value of microseconds passed since January 1 1970 into file time data structure.
     * \param   timeValue   64-bit value as microseconds passed since January 1 1970.
     * \param   fileTime    On output the file-time parameter contains date-time of converted time.
     **/
    AREG_API void convToFileTime( const TIME64 & IN timeValue, sFileTime & OUT fileTime );

    /**
     * \brief   Converts given system-time data structure into file-time data structure.
     * \param   sysTime     The system-time data structure to convert.
     * \param   fileTime    On output the file-time parameter contains date-time of converted time.
     **/
    AREG_API void convToFileTime( const sSystemTime & IN sysTime, sFileTime & OUT fileTime );

    /**
     * \brief   Compare 2 system-time data structures and returns result indicating equality of data.
     * \param   lhs     Left-Hand Operand to compare
     * \param   rhs     Right-Hand Operand to compare
     * \return  Returns one of possible results: 
     *              - NEMath::Smaller if Left-Hand Operand 'lhs' is smaller than Right-Hand Operand 'rhs'
     *              - NEMath::Equal if both operands are equal
     *              - NEMath::Bigger  if Left-Hand Operand 'lhs' is greater than Right-Hand Operand 'rhs'
     **/
    AREG_API NEMath::eCompare compareTimes( const sSystemTime & lhs, const sSystemTime & rhs );

    /**
     * \brief   Compare 2 file-time data structures and returns result indicating equality of data.
     * \param   lhs     Left-Hand Operand to compare
     * \param   rhs     Right-Hand Operand to compare
     * \return  Returns one of possible results: 
     *              - NEMath::Smaller if Left-Hand Operand 'lhs' is smaller than Right-Hand Operand 'rhs'
     *              - NEMath::Equal if both operands are equal
     *              - NEMath::Bigger  if Left-Hand Operand 'lhs' is greater than Right-Hand Operand 'rhs'
     **/
    AREG_API NEMath::eCompare compareTimes( const sFileTime & lhs, const sFileTime & rhs );

    /**
     * \brief   Compare 2 64-bit time values and returns result indicating equality of data. The given 64-values
     *          are microseconds passed since 1 January 1970.
     * \param   lhs     Left-Hand Operand to compare
     * \param   rhs     Right-Hand Operand to compare
     * \return  Returns one of possible results: 
     *              - NEMath::Smaller if Left-Hand Operand 'lhs' is smaller than Right-Hand Operand 'rhs'
     *              - NEMath::Equal if both operands are equal
     *              - NEMath::Bigger  if Left-Hand Operand 'lhs' is greater than Right-Hand Operand 'rhs'
     **/
    AREG_API NEMath::eCompare compareTimes( const TIME64 & lhs, const TIME64 & rhs );

    /**
     * \brief   Converts system-time data structure to standard 'tm' type. In conversion, a milliseconds part of data will be lost.
     * \param   sysTime     The system-time data structure to convert.
     * \param   time        On output the parameter contains date-time of converted system time without information of milliseconds.
     **/
    AREG_API void convToTm( const sSystemTime & IN sysTime, struct tm & OUT time );

    /**
     * \brief   Converts standard 'tm' type to system-time data structure. In conversion, a milliseconds part of data will not exist.
     * \param   time        Contains date-time of converted system time without information of milliseconds.
     * \param   sysTime     On output, the parameter contains date-time information in system-time data structure format without millisecond information.
     **/
    AREG_API void convToSystemTime( const tm & IN time, sSystemTime & OUT sysTime );

    /**
     * \brief   Localizes the UTC time data value. On output the passed structure contains values in UTC timezone.
     * \param   utcTime [in, out]   The time structure in UTC time to convert.
     *                              On output the values of structure will be in local time zone.
     **/
    AREG_API void makeTmLocal( struct tm & IN OUT utcTime );

    /**
     * \brief   Returns the tick counts information in milliseconds since process has started.
     **/
    AREG_API TIME64 getTickCount( void );

    /**
     * \brief   Converts the system UTC time to local time.
     * \param   utcTime     The UTC time to convert.
     * \param   localTime   On output this structure contains the converted local time.
     * \return  Returns true if conversion succeeded.
     **/
    AREG_API bool convToLocalTime( const sSystemTime & IN utcTime, sSystemTime & OUT localTime );

    /**
     * \brief   Converts the system UTC time to local time.
     * \param   inUtcTime       The UTC time in microseconds passed since January 1 1970
     * \param   outLocalTime    On return this structure contains the local time information.
     * \return  Returns true if conversion succeeded.
     **/
    AREG_API bool convToLocalTime( const TIME64 & IN utcTime, sSystemTime & OUT localTime );

/************************************************************************/
// NEUtilities namespace utility functions, generate names
/************************************************************************/
    /**
     * \brief   Creates Component item name separating by COMPONENT_ITEM_SEPARATOR if component name is given.
     *          Otherwise, it will return itemName
     * \param   componentName   The name of item parent component, normally component role name
     * \param   itemName        The name of component item.
     * \return  Returns created new string containing componentName and itemName separated by COMPONENT_ITEM_SEPARATOR.
     **/
    AREG_API String createComponentItemName(const String & componentName, const String & itemName);

    /**
     * \brief   This function generates and returns name 
     *          using time-stamp value in nanoseconds in the name.
     *          If passed prefix is nullptr, it will use predefined
     *          NEUtilities::DEFAULT_GENERATED_NAME constant as a
     *          prefix for name. The maximum length of generated
     *          name is NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE.
     *          To provide uniqueness for generated name, make
     *          sure that the length of passed prefix is not
     *          more than (NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE - 34)
     * \param   prefix  The prefix to add in generated name.
     *                  If this value is nullptr it will use
     *                  NEUtilities::DEFAULT_GENERATED_NAME as
     *                  a prefix for name.
     * \return  Returns system generated unique name.
     **/
    AREG_API String generateName( const char * prefix );

    /**
     * \brief   This function generates and returns name 
     *          using time-stamp value in nanoseconds in the name.
     *          If passed prefix is nullptr, it will use predefined
     *          NEUtilities::DEFAULT_GENERATED_NAME constant as a
     *          prefix for name. Before calling this function,
     *          the output buffer should be allocated and the length
     *          of buffer should be big enough to contain prefix
     *          and the time-stamp. The time-stamp requires at least
     *          34 characters. Generated output name is in 
     *          format <prefix>:{nn:nn:nn:nn:nn:nn:nn:nn})
     * \param   prefix              The prefix to add in generated name.
     *                              If this value is nullptr it will use
     *                              NEUtilities::DEFAULT_GENERATED_NAME as
     *                              a prefix for name.
     * \param   out_buffer [out]    The output buffer to fill generated name.
     *                              The length of buffer should be big enough
     *                              to contain prefix and prefix.
     * \param   length              The length of buffer to set name.
     * \param   specChar    Special character used in generated name.
     * \return  Returns the content of 'out_buffer'. If 'out_buffer' is invalid, returns nullptr.
     **/
    AREG_API const char * generateName( const char * prefix, char * OUT out_buffer, int length);
    AREG_API const char * generateName( const char * prefix, char * OUT out_buffer, int length, const char * specChar);

/************************************************************************/
// NEUtilities namespace utility functions, generate unique ID
/************************************************************************/
    /**
     * \brief	Generates and returns unique unsigned int value
     **/
    AREG_API unsigned int generateUniqueId( void );

    //!< The data rate type
    typedef std::pair<double, std::string_view>     DataLiteral;

    /**
     * \brief   Converts the data size in bytes value into readable values bytes, kilobytes or megabytes.
     *          In the returned pair type, first parameter contains converted size and the second
     *          contains the string literal of the size.
     * 
     * \param   dataSize    The data size in bytes to convert.
     * \return  Returns a pair where the first value contains converted size and
     *          the second value is the string literal of converted size. For example,
     *          the value 2500 bytes is converted in pairs <2.5, 'KBytes'>, i.e. 2.5 kilobytes.
     */
    AREG_API DataLiteral convDataSize( uint64_t dataSize );

    /**
     * \brief   Converts the time duration in nanoseconds value into readable values nanoseconds,
     *          microseconds, milliseconds or seconds.
     *          In the returned pair type, first parameter contains converted duration and the second
     *          contains the string literal of the duration.
     *
     * \param   timeDuration    The time duration in nanoseconds to convert.
     * \return  Returns a pair where the value is converted time and the second value
     *          is a literal of the converted time. For example, the value 2500 is
     *          converted into pair <2.5, 'us'>, i.e. 2.5 microseconds.
     */
    AREG_API DataLiteral convDuration( uint64_t timeDuration );

    /**
     * \brief   A helper class to calculate time passed. Can be used as a stop watch.
     *          Need to call stop() method to calculate the duration.
     *          Otherwise, the duration is zero.
     * 
     * \example Use of NEUtilities::TimeDuration:
     * 
     *          NEUtilities::TimeDuration stopWatch;
     *          stopWatch.stop();
     *          std::cout << "Time passed " << stopWatch.passedMillisecond() << " ms" << std::endl;
     * 
     *          std::cout << "Started new timer at epoch time " << stopWatch.start() << std::endl;
     *          std::cout << "Stoppedn timer at epoch time " << stopWatch.stop() << std::endl;
     *          std::cout << "Time passed: " << stopWatch.passedNanoseconds() << " ns" << std::endl;
     **/
    class TimeDuration
    {
    //////////////////////////////////////////////////////////////////////////
    // Constructors / Destructor, operators
    //////////////////////////////////////////////////////////////////////////
    public:
        /**
         * \brief   Initializes the start and stop times since epoch.
         *          If call start(), it resets starting time.
         *          Call stop() to calculate the duration.
         **/
        inline TimeDuration( void );
        TimeDuration( const TimeDuration & src ) = default;
        ~TimeDuration( void ) = default;

        TimeDuration & operator = ( const TimeDuration & src ) = default;

    //////////////////////////////////////////////////////////////////////////
    // Operations, attributes.
    //////////////////////////////////////////////////////////////////////////
    public:

        /**
         * \brief   Starts the timer. Call stop() to calculate duration.
         * \return  Returns the starting time in nanoseconds passed since epoch.
         **/
        inline TIME64 start( void );

        /**
         * \brief   Stops the timer, can calculate duration.
         * \return  Returns the stopping time in nanoseconds passed since epoch.
         **/
        inline TIME64 stop( void );

        /**
         * \bief    Returns the starting time in nanoseconds since epoch.
         **/
        inline TIME64 getStart( void ) const;

        /**
         * \bief    Returns the stopping time in nanoseconds since epoch.
         **/
        inline TIME64 getStop( void ) const;

        /**
         * \brief   Calculates and returns passed time in nanoseconds.
         **/
        inline uint64_t passedNanoseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in microseconds.
         **/
        inline uint64_t passedMicroseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in milliseconds.
         **/
        inline uint64_t passedMilliseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in seconds.
         **/
        inline uint64_t passedSeconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in minutes.
         **/
        inline uint64_t passedMinutes( void ) const;

    //////////////////////////////////////////////////////////////////////////
    // Member variables
    //////////////////////////////////////////////////////////////////////////
    private:
        //!< The high-resolution starting time since epoch.
        std::chrono::steady_clock::time_point   mStart;
        //!< The high-resolution stopping time since epoch.
        std::chrono::steady_clock::time_point   mStop;
    };
}

//////////////////////////////////////////////////////////////////////////
// NEUtilities::TimeDuration inline methods
//////////////////////////////////////////////////////////////////////////

inline NEUtilities::TimeDuration::TimeDuration( void )
    : mStart        ( std::chrono::steady_clock::now() )
    , mStop         ( mStart )
{
}

inline TIME64 NEUtilities::TimeDuration::start( void )
{
    mStart      = std::chrono::steady_clock::now();
    mStop       = mStart;

    return mStart.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::TimeDuration::stop( void )
{
    mStop = std::chrono::steady_clock::now();
    return mStop.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::TimeDuration::getStart( void ) const
{
    return mStart.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::TimeDuration::getStop( void ) const
{
    return mStop.time_since_epoch( ).count( );
}

inline uint64_t NEUtilities::TimeDuration::passedNanoseconds( void ) const
{
    return (mStop - mStart).count();
}

inline uint64_t NEUtilities::TimeDuration::passedMicroseconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::microseconds>(mStop - mStart).count();
}

inline uint64_t NEUtilities::TimeDuration::passedMilliseconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(mStop - mStart).count( );
}

inline uint64_t NEUtilities::TimeDuration::passedSeconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::seconds>(mStop - mStart).count( );
}

inline uint64_t NEUtilities::TimeDuration::passedMinutes( void ) const
{
    return std::chrono::duration_cast<std::chrono::minutes>(mStop - mStart).count( );
}

#endif  // AREG_BASE_NEUTILITIES_HPP
