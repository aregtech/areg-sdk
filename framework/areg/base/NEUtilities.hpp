#ifndef AREG_BASE_NEUTILITIES_HPP
#define AREG_BASE_NEUTILITIES_HPP
/************************************************************************
 * This file is part of the AREG SDK core engine.
 * AREG SDK is dual-licensed under Free open source (Apache version 2.0
 * License) and Commercial (with various pricing models) licenses, depending
 * on the nature of the project (commercial, research, academic or free).
 * You should have received a copy of the AREG SDK license description in LICENSE.txt.
 * If not, please contact to info[at]aregtech.com
 *
 * \copyright   (c) 2017-2023 Aregtech UG. All rights reserved.
 * \file        areg/base/NEUtilities.hpp
 * \ingroup     AREG SDK, Automated Real-time Event Grid Software Development Kit 
 * \author      Artak Avetyan
 * \brief       AREG Platform, Utilities
 *              Helper functions and constants.
 *
 ************************************************************************/
/************************************************************************
 * Include files.
 ************************************************************************/
#include "areg/base/GEGlobal.h"
#include "areg/base/NEMath.hpp"

#include <chrono>
#include <string_view>
#include <utility>

/************************************************************************
 * Dependencies
 ************************************************************************/
class String;
class IEInStream;
class IEOutStream;

struct tm;

//////////////////////////////////////////////////////////////////////////
// NEUtilities namespace declaration
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   Collection of helper functions and constants.
 *          For details see description of constants and functions.
 *
 **/
namespace   NEUtilities
{
/************************************************************************/
// NEUtilities namespace predefined constants
/************************************************************************/

    /**
     * \brief   NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE
     *          Constants. Predefined value, the maximum length of name
     *          generated by system.
     **/
    constexpr int                   MAX_GENERATED_NAME_BUFFER_SIZE  	{ 0xFF };

    /**
     * \brief   NEUtilities::DEFAULT_GENERATED_NAME
     *          Constant. Predefined default prefix for generated
     *          by system names.
     **/
    constexpr std::string_view      DEFAULT_GENERATED_NAME          	{ "Name" };
    /**
     * \brief   NEUtilities::ITEM_NAMES_MAX_LENGTH
     *          The maximum length of item names such as thread name, component or service names
     **/
    constexpr unsigned int          ITEM_NAMES_MAX_LENGTH           	{ 64 };

    /**
     * \brief   NEUtilities::WIN_TO_POSIX_EPOCH_BIAS_MICROSECS
     *          The difference in microseconds between Windows and Unix epoch.
     **/
    constexpr TIME64                WIN_TO_POSIX_EPOCH_BIAS_MICROSECS	{11644473600000000LL};

    /**
     * \brief   NEUtilities::SEC_TO_MILLISECS
     *          Milliseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_MILLISECS                    { 1'000LL };

    /**
     * \brief   NEUtilities::SEC_TO_MICROSECS
     *          Microseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_MICROSECS                    { 1'000'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_MICROSECS
     *          Microseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_MICROSECS               { 1'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_100NS
     *          100 nanoseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_100NS                   { 10'000LL };

    /**
     * \brief   NEUtilities::MILLISEC_TO_NS
     *          Nanoseconds in 1 millisecond.
     **/
    constexpr TIME64                MILLISEC_TO_NS                      { 1'000'000LL };

    /**
     * \brief   NEUtilities::SEC_TO_NS
     *          Nanoseconds in 1 second.
     **/
    constexpr TIME64                SEC_TO_NS                      		{ 1'000'000'000LL };

    /**
     * \brief   NEUtilities::MICROSEC_TO_100NS
     *          100-nanoseconds in 1 microsecond.
     **/
    constexpr TIME64                MICROSEC_TO_100NS                   { 10LL };

    /**
     * \brief   NEUtilities::MICROSEC_TO_NS
     *          Nanoseconds in 1 microsecond.
     **/
    constexpr TIME64                MICROSEC_TO_NS                    	{ 1'000LL };

    /**
     * \brief   NEUtilities::MIN_TO_SECS
     *          Seconds in 1 minute.
     **/
    constexpr TIME64                MIN_TO_SECS                         { 60LL };

    /**
     * \brief   NEUtilities::MIN_TO_MILLISECS
     *          Milliseconds in 1 minute.
     **/
    constexpr TIME64                MIN_TO_MILLISECS                    { MIN_TO_SECS * SEC_TO_MILLISECS };

    /**
     * \brief   NEUtilities::MIN_TO_MICROSECS
     *          Microseconds in 1 minute.
     **/
    constexpr TIME64                MIN_TO_MICROSECS                    { MIN_TO_SECS * SEC_TO_MICROSECS };

    /**
     * \brief   NEUtilities::HOUR_TO_MINS
     *          Minutes in 1 hour.
     **/
    constexpr TIME64                HOUR_TO_MINS                        { 60LL };

    /**
     * \brief   NEUtilities::HOUR_TO_SECS
     *          Seconds in 1 hour.
     **/
    constexpr TIME64                HOUR_TO_SECS                        { HOUR_TO_MINS * MIN_TO_SECS };

    /**
     * \brief   NEUtilities::HOUR_TO_MILLISECS
     *          Milliseconds in 1 hour.
     **/
    constexpr TIME64                HOUR_TO_MILLISECS                   { HOUR_TO_SECS * SEC_TO_MILLISECS };

    /**
     * \brief   NEUtilities::HOUR_TO_MICROSECS
     *          Microseconds in 1 hour.
     **/
    constexpr TIME64                HOUR_TO_MICROSECS                   { HOUR_TO_SECS * SEC_TO_MICROSECS };

    /**
     * \brief   NEUtilities::DAY_TO_HOURS
     *          Hours in 1 day.
     **/
    constexpr TIME64                DAY_TO_HOURS                        { 24LL };

    /**
     * \brief   NEUtilities::DAY_TO_MINS
     *          Minutes in 1 day.
     **/
    constexpr TIME64                DAY_TO_MINS                         { DAY_TO_HOURS * HOUR_TO_MINS };

    /**
     * \brief   NEUtilities::DAY_TO_SECS
     *          Seconds in 1 day.
     **/
    constexpr TIME64                DAY_TO_SECS                         { DAY_TO_MINS * MIN_TO_SECS };

    /**
     * \brief   NEUtilities::DAY_TO_MILLISECS
     *          Milliseconds in 1 day.
     **/
    constexpr TIME64                DAY_TO_MILLISECS                    { DAY_TO_SECS * SEC_TO_MILLISECS };

    /**
     * \brief   NEUtilities::DAY_TO_MICROSECS
     *          Microseconds in 1 day.
     **/
    constexpr TIME64                DAY_TO_MICROSECS                    { DAY_TO_SECS * SEC_TO_MICROSECS };

    /**
     * \brief   NEUtilities::YEAR_TO_DAYS
     *          Days in 1 year.
     **/
    constexpr TIME64                YEAR_TO_DAYS                        { 365LL };

    /**
     * \brief   NEUtilities::YEAR_TO_HOURS
     *          Hours in 1 year.
     **/
    constexpr TIME64                YEAR_TO_HOURS                       { YEAR_TO_DAYS * DAY_TO_HOURS };

    /**
     * \brief   NEUtilities::YEAR_TO_MINS
     *          Minutes in 1 year.
     **/
    constexpr TIME64                YEAR_TO_MINS                        { YEAR_TO_HOURS * HOUR_TO_MINS};

    /**
     * \brief   NEUtilities::YEAR_TO_SECS
     *          Seconds in 1 year.
     **/
    constexpr TIME64                YEAR_TO_SECS                        { YEAR_TO_MINS * MIN_TO_SECS };

    /**
     * \brief   NEUtilities::YEAR_TO_MILLISECS
     *          Milliseconds in 1 year.
     **/
    constexpr TIME64                YEAR_TO_MILLISECS                   { YEAR_TO_SECS * SEC_TO_MILLISECS };

    /**
     * \brief   NEUtilities::YEAR_TO_MICROSECS
     *          Microseconds in 1 year.
     **/
    constexpr TIME64                YEAR_TO_MICROSECS                   { YEAR_TO_SECS * SEC_TO_MICROSECS };

    /**
     * \brief   NEUtilities::YEAR_TO_DAYS_EX
     *          Days in 1 leap year
     **/
    constexpr TIME64                YEAR_TO_DAYS_EX                     { 366LL };

    /**
     * \brief   NEUtilities::YEAR_TO_HOURS_EX
     *          Hours in 1 leap year.
     **/
    constexpr TIME64                YEAR_TO_HOURS_EX                    { YEAR_TO_DAYS * DAY_TO_HOURS };

    /**
     * \brief   NEUtilities::YEAR_TO_MINS_EX
     *          Minutes in 1 leap year.
     **/
    constexpr TIME64                YEAR_TO_MINS_EX                     { YEAR_TO_HOURS * HOUR_TO_MINS};

    /**
     * \brief   NEUtilities::YEAR_TO_SECS_EX
     *          Seconds in 1 leap year.
     **/
    constexpr TIME64                YEAR_TO_SECS_EX                     { YEAR_TO_MINS * MIN_TO_SECS };

    /**
     * \brief   NEUtilities::YEAR_TO_MILLISECS_EX
     *          Milliseconds in 1 year.
     **/
    constexpr TIME64                YEAR_TO_MILLISECS_EX                { YEAR_TO_SECS * SEC_TO_MILLISECS };

    /**
     * \brief   NEUtilities::YEAR_TO_MICROSECS_EX
     *          Microseconds in 1 year.
     **/
    constexpr TIME64                YEAR_TO_MICROSECS_EX                { YEAR_TO_SECS * SEC_TO_MICROSECS };


/************************************************************************/
// NEUtilities namespace utility types
/************************************************************************/

    /**
     * \brief   NEUtilities::sSystemTime
     *          The structure defines date-time data used in system time
     **/
    typedef struct S_SystemTime
    {
        int     stYear{ 0 };        //!< The year in the time
        int     stMonth{ 0 };       //!< The month in the time, which starts from 1 (January) until 12 (December)
        int     stDayOfWeek{ 0 };   //!< The day of week in the time, which starts from 1 (Sunday) until 7 (Saturday)
        int     stDayOfYear{ 0 };   //!< The day of the year, which starts from 1 to 365
        int     stDay{ 0 };         //!< The day of the month in the time, which starts from 1
        int     stHour{ 0 };        //!< The hour in the time, which starts from 0
        int     stMinute{ 0 };      //!< The minute in the time, which starts from 0
        int     stSecond{ 0 };      //!< The second in the time, which starts from 0
        int     stMillisecs{ 0 };   //!< The millisecond in the time, which starts from 0
        int     stMicrosecs{ 0 };   //!< The microseconds in the time, which starts from 0
    } sSystemTime;

    /**
     * \brief   Converts time in microseconds to time in seconds.
     * \param   microseconds    The time in microseconds.
     * \return  Returns time in seconds.
     **/
    inline time_t convToSeconds(const TIME64 & microsecs);

    /**
     * \brief   Converts the broken time to seconds, throwing out the milliseconds and microseconds.
     * \param   sysTime     The broken time to convert.
     * \return  Returns time in seconds.
     **/
    AREG_API time_t convToSeconds(const sSystemTime& sysTime);

    /**
     * \brief   Returns current time. On output 'out_sysTime' system time contains the date-time data.
     * \param   sysTime     On output the system time parameter contains date-time of current time.
     * \param   localTime   If true, in output the out_sysTime contains local time values.
     **/
    AREG_API void systemTimeNow( sSystemTime & OUT sysTime, bool localTime );

    /**
     * \brief   Returns current system time data as a 64-bit integer value. The returned value is
     *          passed microseconds since January 1, 1970 (UNIX epoch).
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 systemTimeNow( void );

    /**
     * \brief   Returns system time data as a 64-bit integer value in microseconds passed since Unix epoch,
     *          which is January 1, 1970 (UNIX epoch).
     * \param   sysTime     The system time structure with data to convert.
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 convToTime( const sSystemTime & IN sysTime );

    /**
     * \brief   Returns tm structure data as a 64-bit integer value in microseconds passed since Unix epoch,
     *          which is January 1, 1970 (UNIX epoch).
     * \param   sysTime     The system time structure with data to convert.
     * \return  Returns microseconds passed since January 1, 1970 (UNIX epoch).
     **/
    AREG_API TIME64 convToTime(const struct tm& IN time);

    /**
     * \brief   Converts 64-bit value of microseconds passed since January 1 1970 into system time data structure.
     * \param   timeValue   64-bit value as microseconds passed since January 1 1970.
     * \param   sysTime     On output the system time parameter contains date-time of converted time.
     **/
    AREG_API void convToSystemTime( const TIME64 & IN timeValue, sSystemTime & OUT sysTime );

    /**
     * \brief   Compare 2 system-time data structures and returns result indicating equality of data.
     * \param   lhs     Left-Hand Operand to compare
     * \param   rhs     Right-Hand Operand to compare
     * \return  Returns one of possible results: 
     *              - NEMath::Smaller if Left-Hand Operand 'lhs' is smaller than Right-Hand Operand 'rhs'
     *              - NEMath::Equal if both operands are equal
     *              - NEMath::Bigger  if Left-Hand Operand 'lhs' is greater than Right-Hand Operand 'rhs'
     **/
    AREG_API NEMath::eCompare compareTimes( const sSystemTime & lhs, const sSystemTime & rhs );

    /**
     * \brief   Compare 2 64-bit time values and returns result indicating equality of data. The given 64-values
     *          are microseconds passed since 1 January 1970.
     * \param   lhs     Left-Hand Operand to compare
     * \param   rhs     Right-Hand Operand to compare
     * \return  Returns one of possible results: 
     *              - NEMath::Smaller if Left-Hand Operand 'lhs' is smaller than Right-Hand Operand 'rhs'
     *              - NEMath::Equal if both operands are equal
     *              - NEMath::Bigger  if Left-Hand Operand 'lhs' is greater than Right-Hand Operand 'rhs'
     **/
    AREG_API NEMath::eCompare compareTimes( const TIME64 & lhs, const TIME64 & rhs );

    /**
     * \brief   Converts given time in microseconds into the time in seconds, milliseconds and microseconds.
     *
     * \param   time[in]    The time in microseconds to parse and extract.
     * \param   secs[out]   On output, this contains the time in seconds.
     * \param   milli[out]  On output, this contains the remaining time in milliseconds.
     * \param   micro[out]  On output, this contains the remaining time in microseconds.
     **/
    AREG_API void convMicrosecs(const TIME64 & IN time, time_t & OUT secs, unsigned short & OUT milli, unsigned short & OUT micro);

    /**
     * \brief   Converts system-time data structure to standard 'tm' type. In conversion, a milliseconds part of data will be lost.
     * \param   sysTime     The system-time data structure to convert.
     * \param   time        On output the parameter contains date-time of converted system time without information of milliseconds.
     **/
    AREG_API void convToTm( const sSystemTime & IN sysTime, struct tm & OUT time );

    /**
     * \brief   Converts time in microseconds since Unix epoch (January 1, 1970) to standard 'tm' type.
     *          In conversion, a milliseconds and microseconds part of data will be lost.
     * \param   timeMicro   The time in microseconds since Unix epoch (January 1, 1970) to convert.
     * \param   time        On output the parameter contains date-time of converted system time without information of milliseconds.
     **/
    AREG_API void convToTm(const TIME64& IN timeMicro, struct tm& OUT time);

    /**
     * \brief   Converts standard 'tm' type to system-time data structure. In conversion, a milliseconds part of data will not exist.
     * \param   time        Contains date-time of converted system time without information of milliseconds.
     * \param   sysTime     On output, the parameter contains date-time information in system-time data structure format without millisecond information.
     **/
    AREG_API void convToSystemTime( const struct tm & IN time, sSystemTime & OUT sysTime );

    /**
     * \brief   Localizes the UTC time data value. On output the passed structure contains values in UTC timezone.
     * \param   utcTime [in, out]   The time structure in UTC time to convert.
     *                              On output the values of structure will be in local time zone.
     **/
    AREG_API void makeTmLocal( struct tm & IN OUT utcTime );

    /**
     * \brief   Returns the tick counts information in milliseconds since process has started.
     **/
    AREG_API TIME64 getTickCount( void );

    /**
     * \brief   Converts the system UTC time to local time.
     * \param   utcTime     The UTC time to convert.
     * \param   localTime   On output this structure contains the converted local time.
     * \return  Returns true if conversion succeeded.
     **/
    AREG_API bool convToLocalTime( const sSystemTime & IN utcTime, sSystemTime & OUT localTime );

    /**
     * \brief   Converts the system UTC time to local time.
     * \param   utcTime     The UTC time in microseconds passed since January 1 1970
     * \param   localTime   On return this structure contains the local time information.
     * \return  Returns true if conversion succeeded.
     **/
    AREG_API bool convToLocalTime( const TIME64 & IN utcTime, sSystemTime & OUT localTime );

    /**
     * \brief   Converts the system UTC time to local time in structure of tm.
     * \param   utcTime     The UTC time in microseconds passed since January 1 1970
     * \param   localTm     On return this structure contains the local time information.
     * \return  Returns true if conversion succeeded.
     **/
    AREG_API bool convToLocalTm(const TIME64 & IN utcTime, struct tm & OUT localTm);

/************************************************************************/
// NEUtilities namespace utility functions, generate names
/************************************************************************/
    /**
     * \brief   Creates Component item name separating by COMPONENT_ITEM_SEPARATOR if component name is given.
     *          Otherwise, it will return itemName
     * \param   componentName   The name of item parent component, normally component role name
     * \param   itemName        The name of component item.
     * \return  Returns created new string containing componentName and itemName separated by COMPONENT_ITEM_SEPARATOR.
     **/
    AREG_API String createComponentItemName(const String & componentName, const String & itemName);

    /**
     * \brief   This function generates and returns name 
     *          using time-stamp value in nanoseconds in the name.
     *          If passed prefix is nullptr, it will use predefined
     *          NEUtilities::DEFAULT_GENERATED_NAME constant as a
     *          prefix for name. The maximum length of generated
     *          name is NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE.
     *          To provide uniqueness for generated name, make
     *          sure that the length of passed prefix is not
     *          more than (NEUtilities::MAX_GENERATED_NAME_BUFFER_SIZE - 34)
     * \param   prefix  The prefix to add in generated name.
     *                  If this value is nullptr it will use
     *                  NEUtilities::DEFAULT_GENERATED_NAME as
     *                  a prefix for name.
     * \return  Returns system generated unique name.
     **/
    AREG_API String generateName( const char * prefix );

    /**
     * \brief   This function generates and returns name 
     *          using time-stamp value in nanoseconds in the name.
     *          If passed prefix is nullptr, it will use predefined
     *          NEUtilities::DEFAULT_GENERATED_NAME constant as a
     *          prefix for name. Before calling this function,
     *          the output buffer should be allocated and the length
     *          of buffer should be big enough to contain prefix
     *          and the time-stamp. The time-stamp requires at least
     *          34 characters. Generated output name is in 
     *          format <prefix>:{nn:nn:nn:nn:nn:nn:nn:nn})
     * \param   prefix              The prefix to add in generated name.
     *                              If this value is nullptr it will use
     *                              NEUtilities::DEFAULT_GENERATED_NAME as
     *                              a prefix for name.
     * \param   out_buffer [out]    The output buffer to fill generated name.
     *                              The length of buffer should be big enough
     *                              to contain prefix and prefix.
     * \param   length              The length of buffer to set name.
     * \param   specChar    Special character used in generated name.
     * \return  Returns the content of 'out_buffer'. If 'out_buffer' is invalid, returns nullptr.
     **/
    AREG_API const char * generateName( const char * prefix, char * OUT out_buffer, int length);
    AREG_API const char * generateName( const char * prefix, char * OUT out_buffer, int length, const char * specChar);

/************************************************************************/
// NEUtilities namespace utility functions, generate unique ID
/************************************************************************/
    /**
     * \brief	Generates and returns unique unsigned int value
     **/
    AREG_API unsigned int generateUniqueId( void );

    //!< The data rate type
    typedef std::pair<double, std::string_view>     DataLiteral;

    /**
     * \brief   Converts the data size in bytes value into readable values bytes, kilobytes or megabytes.
     *          In the returned pair type, first parameter contains converted size and the second
     *          contains the string literal of the size.
     * 
     * \param   dataSize    The data size in bytes to convert.
     * \return  Returns a pair where the first value contains converted size and
     *          the second value is the string literal of converted size. For example,
     *          the value 2500 bytes is converted in pairs <2.5, 'KBytes'>, i.e. 2.5 kilobytes.
     */
    AREG_API DataLiteral convDataSize( uint64_t dataSize );

    /**
     * \brief   Converts the time duration in nanoseconds value into readable values nanoseconds,
     *          microseconds, milliseconds or seconds.
     *          In the returned pair type, first parameter contains converted duration and the second
     *          contains the string literal of the duration.
     *
     * \param   timeDuration    The time duration in nanoseconds to convert.
     * \return  Returns a pair where the value is converted time and the second value
     *          is a literal of the converted time. For example, the value 2500 is
     *          converted into pair <2.5, 'us'>, i.e. 2.5 microseconds.
     */
    AREG_API DataLiteral convDuration( uint64_t timeDuration );

    /**
     * \brief   A helper class to calculate time passed. Can be used as a stop watch.
     *          Need to call stop() method to calculate the duration.
     *          Otherwise, the duration is zero.
     * 
     * \example Use of NEUtilities::Duration:
     * 
     *          NEUtilities::Duration stopWatch;
     *          stopWatch.stop();
     *          std::cout << "Time passed " << stopWatch.passedMillisecond() << " ms" << std::endl;
     * 
     *          std::cout << "Started new timer at epoch time " << stopWatch.start() << std::endl;
     *          std::cout << "Stopped timer at epoch time " << stopWatch.stop() << std::endl;
     *          std::cout << "Time passed: " << stopWatch.passedNanoseconds() << " ns" << std::endl;
     **/
    class AREG_API Duration
    {
    //////////////////////////////////////////////////////////////////////////
    // Constructors / Destructor, operators
    //////////////////////////////////////////////////////////////////////////
    public:
        /**
         * \brief   Initializes the start and stop times since epoch.
         *          If call start(), it resets starting time.
         *          Call stop() to calculate the duration.
         **/
        inline Duration( void );
        Duration( const Duration & src ) = default;
        ~Duration( void ) = default;

        Duration & operator = ( const Duration & src ) = default;

    //////////////////////////////////////////////////////////////////////////
    // Operations, attributes.
    //////////////////////////////////////////////////////////////////////////
    public:

        /**
         * \brief   Starts the timer. Call stop() to calculate duration.
         * \return  Returns the starting time in nanoseconds passed since epoch.
         **/
        inline TIME64 start( void );

        /**
         * \brief   Stops the timer, can calculate duration.
         * \return  Returns the stopping time in nanoseconds passed since epoch.
         **/
        inline TIME64 stop( void );

        /**
         * \brief   Returns the starting time in nanoseconds since epoch.
         **/
        inline TIME64 getStart( void ) const;

        /**
         * \brief   Returns the stopping time in nanoseconds since epoch.
         **/
        inline TIME64 getStop( void ) const;

        /**
         * \brief   Calculates and returns passed time in nanoseconds.
         **/
        inline uint64_t passedNanoseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in microseconds.
         **/
        inline uint64_t passedMicroseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in milliseconds.
         **/
        inline uint64_t passedMilliseconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in seconds.
         **/
        inline uint64_t passedSeconds( void ) const;

        /**
         * \brief   Calculates and returns passed time in minutes.
         **/
        inline uint64_t passedMinutes( void ) const;

        /**
         * \brief   Returns the duration in nanoseconds since watch timer started.
         *          If the stop was called before, it returns the duration between start and stop calls.
         *          If the stop was not called, it returns the duration since last time started. 
         **/
        inline uint64_t durationSinceStart( void ) const;

    //////////////////////////////////////////////////////////////////////////
    // Member variables
    //////////////////////////////////////////////////////////////////////////
    private:
#if defined(_MSC_VER) && (_MSC_VER > 1200)
    #pragma warning(disable: 4251)
#endif  // _MSC_VER
        //!< The high-resolution starting time since epoch.
        std::chrono::steady_clock::time_point   mStart;
        //!< The high-resolution stopping time since epoch.
        std::chrono::steady_clock::time_point   mStop;
#if defined(_MSC_VER) && (_MSC_VER > 1200)
    #pragma warning(default: 4251)
#endif  // _MSC_VER
    };
}

//////////////////////////////////////////////////////////////////////////
// NEUtilities::Duration inline methods
//////////////////////////////////////////////////////////////////////////

time_t NEUtilities::convToSeconds(const TIME64& microsecs)
{
    return static_cast<time_t>(microsecs / NEUtilities::SEC_TO_MICROSECS);
}

//////////////////////////////////////////////////////////////////////////
// NEUtilities::Duration inline methods
//////////////////////////////////////////////////////////////////////////

inline NEUtilities::Duration::Duration( void )
    : mStart        ( std::chrono::steady_clock::now() )
    , mStop         ( mStart )
{
}

inline TIME64 NEUtilities::Duration::start( void )
{
    mStart      = std::chrono::steady_clock::now();
    mStop       = mStart;

    return mStart.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::Duration::stop( void )
{
    if ( mStop == mStart )
    {
        mStop = std::chrono::steady_clock::now( );
    }

    return mStop.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::Duration::getStart( void ) const
{
    return mStart.time_since_epoch( ).count( );
}

inline TIME64 NEUtilities::Duration::getStop( void ) const
{
    return mStop.time_since_epoch( ).count( );
}

inline uint64_t NEUtilities::Duration::passedNanoseconds( void ) const
{
    return (mStop - mStart).count();
}

inline uint64_t NEUtilities::Duration::passedMicroseconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::microseconds>(mStop - mStart).count();
}

inline uint64_t NEUtilities::Duration::passedMilliseconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(mStop - mStart).count( );
}

inline uint64_t NEUtilities::Duration::passedSeconds( void ) const
{
    return std::chrono::duration_cast<std::chrono::seconds>(mStop - mStart).count( );
}

inline uint64_t NEUtilities::Duration::passedMinutes( void ) const
{
    return std::chrono::duration_cast<std::chrono::minutes>(mStop - mStart).count( );
}

inline uint64_t NEUtilities::Duration::durationSinceStart( void ) const
{
    return (mStop > mStart ? (mStop - mStart).count( ) : (std::chrono::steady_clock::now( ) - mStart).count( ));
}

#endif  // AREG_BASE_NEUTILITIES_HPP
