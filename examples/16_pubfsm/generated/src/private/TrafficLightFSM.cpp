
//////////////////////////////////////////////////////////////////////////
// Begin generate TrafficLightFSM.cpp file
//////////////////////////////////////////////////////////////////////////

/************************************************************************
 * (c) copyright    2021
 *                  Generated by AREGtech code generator tool.
 * Generated at     15.08.2021  12:23:44 GMT+02:00 
 ************************************************************************/

/************************************************************************
 * \file            generated/src/private/TrafficLightFSM.cpp
 * \ingroup         TrafficLight State Machine
 * \brief           This is an automatic generated code of TrafficLight 
 *                  State Machine class implementation.
 *                  Do not make changes in the file
 ************************************************************************/

/************************************************************************
 * Include files
 ************************************************************************/
#include "generated/src/private/TrafficLightFSM.hpp"

#include "generated/src/private/IETrafficLightActionHandler.hpp"
#include "areg/component/DispatcherThread.hpp"
#include "areg/trace/GETrace.h"

//////////////////////////////////////////////////////////////////////////
// use of namespace to access defined types directly
//////////////////////////////////////////////////////////////////////////
using namespace NETrafficLightFSM;


//////////////////////////////////////////////////////////////////////////
// Predefined local Macro
//////////////////////////////////////////////////////////////////////////

#define  INFO_PROCESSED(curr, next)         \
    TRACE_DBG("FSM < %s >: The trigger < %s > was processed to switch from state < %s > ==> to state < %s >.", mFsmName.getString(), nameTrigger, getString(curr), getString(next))

#define  INFO_PROCESSED_SAME(state)          \
    TRACE_DBG("FSM < %s >: The trigger < %s > was processed in state < %s >.", mFsmName.getString(), nameTrigger, getString(state))

#define  INFO_NOT_PROCESSED                  \
    TRACE_DBG("FSM < %s >: The trigger < %s > was not processed in state < %s >.", mFsmName.getString(), nameTrigger, getString(mState))

#define  INFO_ACTION_SWITCH(actionName)      \
    TRACE_DBG("FSM < %s >: Processing action < %s > on trigger < %s >.", mFsmName.getString(), (actionName), nameTrigger)

#define  INFO_ACTION_ENTER(actionName)       \
    TRACE_DBG("FSM < %s >: Processing action < %s > entering state < %s >.", mFsmName.getString(), (actionName), getString(nextState))

#define  INFO_ACTION_EXIT(actionName)        \
    TRACE_DBG("FSM < %s >: Processing action < %s > exiting state < %s >.", mFsmName.getString(), (actionName), getString(curState))

#define  INFO_ENTER_STATE(enterState)        \
    TRACE_DBG("FSM < %s >: Entering state ==> < %s >.", mFsmName.getString(), getString(enterState))

#define  INFO_EXIT_STATE(exitState)          \
    TRACE_DBG("FSM < %s >: Leaving state: < %s >.", mFsmName.getString(), getString(exitState))

#define  INFO_GO_STATE(fromState, toState)  \
     TRACE_DBG("FSM < %s >: Switched state: < %s > ==> < %s >.", mFsmName.getString(), getString(fromState), getString(toState))

#define  START_PROCESSING( triggerName )                        \
    bool    isProcessed = false;                                \
    const char* nameTrigger = triggerName;                      \
    if (startProcessing(nameTrigger) == true)                   \
    {                                                           \
        isProcessed = true;                                     \
        do                                                      \
        {


#define  END_PROCESSING( )                                      \
            isProcessed = false;                                \
            INFO_NOT_PROCESSED;                                 \
        } while (false);                                        \
      endProcessing();                                          \
    }                                                           \
    return isProcessed;                         

////////////////////////////////////////////////////////////////////////////////
// Trace scope declaration 
////////////////////////////////////////////////////////////////////////////////
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_initFSM);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_releaseFSM);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_enterState);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_leaveState);

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM::TrafficLightEventConsumer class implementation
////////////////////////////////////////////////////////////////////////////////

TrafficLightFSM::TrafficLightEventConsumer::TrafficLightEventConsumer( TrafficLightFSM & fsm )
    : NETrafficLightFSM::IEFsmEventConsumer ( )
    , mFsm  ( fsm )
{
}

/**
 * \brief   Called to process events
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_TrafficLightEventConsumer_processEvent);
/* --------------------------------------------------------------------- */
void TrafficLightFSM::TrafficLightEventConsumer::processEvent( const NETrafficLightFSM::FsmEventData & data )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_TrafficLightEventConsumer_processEvent);
    if ( mFsm.isOperable() )
    {
        TRACE_DBG("Processing event < %s >.", NETrafficLightFSM::getString(data.mData));
       
        switch ( data.mData )
        {
        case NETrafficLightFSM::eFsmEventData::EVENT_StartTrafficLight:
            mFsm.onEventStartTrafficLight();
            break;

        default:
            TRACE_ERR("Unknown Event was requested to be processed!");
            ASSERT(false);
            break;   // do nothing
        }
    }
    else
    {
        TRACE_WARN("Ignoring event < %s >, the state machine < %s > is not initialized.", NETrafficLightFSM::getString(data.mData), mFsm.mFsmName.getString());
    }
}

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM::TimerConsumer class implementation 
////////////////////////////////////////////////////////////////////////////////

TrafficLightFSM::TrafficLightTimerConsumer::TrafficLightTimerConsumer( TrafficLightFSM & fsm )
    : IETimerConsumer   ( )
    , mFsm              ( fsm )
{
}

/**
 * Called to process expired timers
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_TrafficLightTimerConsumer_processTimer);
/* --------------------------------------------------------------------- */
void TrafficLightFSM::TrafficLightTimerConsumer::processTimer( Timer & timer )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_TrafficLightTimerConsumer_processTimer);
    TRACE_DBG("Processing Timer < %s >.", timer.getName().getString());
    
    do
    {
        if (timer.isStopped() == false)
        {
            if ( &timer == &mFsm.mTimerRed )
            {
                mFsm.onTimerRed( );
                break;
            }
            if ( &timer == &mFsm.mTimerYellowRed )
            {
                mFsm.onTimerYellowRed( );
                break;
            }
            if ( &timer == &mFsm.mTimerGreen )
            {
                mFsm.onTimerGreen( );
                break;
            }
            if ( &timer == &mFsm.mTimerYellowGreen )
            {
                mFsm.onTimerYellowGreen( );
                break;
            }
            if ( &timer == &mFsm.mTimerPedestrianWalk )
            {
                mFsm.onTimerPedestrianWalk( );
                break;
            }
            if ( &timer == &mFsm.mTimerVehicleWait )
            {
                mFsm.onTimerVehicleWait( );
                break;
            }

            TRACE_ERR("Unknown timer was requested to be processed, none of existing timer has matched!");
            ASSERT(false);
        }
        else
        {
            TRACE_WARN("The timer [ %s ] is already stopped, ignoring processing timer.", timer.getName().getString());
        }
        
    } while (false);
}

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM predefined static members 
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM Class constructor / destructor 
////////////////////////////////////////////////////////////////////////////////
TrafficLightFSM::TrafficLightFSM( IETrafficLightActionHandler & actionHandler, const std::string_view & instanceName /* = NETrafficLightFSM::InstanceDefaultName */ )
    : mActionHandler  ( actionHandler )
    
    , mTimerRed( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::Red" )
    , mTimerYellowRed( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::YellowRed" )
    , mTimerGreen( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::Green" )
    , mTimerYellowGreen( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::YellowGreen" )
    , mTimerPedestrianWalk( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::PedestrianWalk" )
    , mTimerVehicleWait( static_cast< IETimerConsumer &>(mTimerConsumer), "TrafficLightFsm::VehicleWait" )
    

    , mFsmName      ( String("TrafficLightFSM:") + instanceName )
    , mMasterThread ( nullptr )
    , mProcessing   ( false )
    , mState        ( TrafficLightFSM::eState::UNDEFINED )
    , mEventConsumer( self() )
    , mTimerConsumer( self() )
{
}

TrafficLightFSM::~TrafficLightFSM( void )
{
    NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(mEventConsumer) );
}

/**
 * Start processing trigger
 **/
inline bool TrafficLightFSM::startProcessing( const char* const triggerName )
{
    bool result = false;
    if (mState == TrafficLightFSM::eState::UNDEFINED)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
        TRACE_ERR("FSM < %s >: The State Machine is not initialized to call trigger < %s >!", mFsmName.getString(), triggerName);
        ASSERT(false);
    }
    else if (mProcessing == true)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
        TRACE_ERR("FSM < %s >: Invalid trigger < %s > call during processing action!", mFsmName.getString(), triggerName);
        ASSERT(false);
    }
    else
    {
        mProcessing = true;
        result      = true;
    }
    return result;
}

/**
 * End processing trigger
 **/
inline void TrafficLightFSM::endProcessing( void )
{
    mProcessing = false;
}

/**
 * Update state tree
 **/
inline void TrafficLightFSM::updateStateTree( const TrafficLightFSM::eState whichState, const TrafficLightFSM::eState curState )
{
    ASSERT(curState   != TrafficLightFSM::eState::STATE_SIZE);

    TrafficLightFSM::eState parent = sParrentStates[static_cast<int>(whichState)];
    if (parent != TrafficLightFSM::eState::UNDEFINED)
    {
        updateStateTree(parent, curState);
    }

    mCurrentStates[static_cast<int>(whichState)] = curState;
}

/**
 * Checks if the state is in parent tree
 **/
inline bool TrafficLightFSM::isInParentTree( TrafficLightFSM::eState whichState, const TrafficLightFSM::eState checkState )
{
    ASSERT(checkState != TrafficLightFSM::eState::UNDEFINED && checkState != TrafficLightFSM::eState::STATE_SIZE);

    bool result = whichState == checkState;
    if (result == false)
    {
        whichState  = sParrentStates[static_cast<int>(whichState)];
        result      = whichState != TrafficLightFSM::eState::UNDEFINED ? isInParentTree(whichState, checkState) : false;
    }

    return result;
}

/**
 * Call to enter state and trigger actions on enter
 **/
inline void TrafficLightFSM::enterState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger )
{
    if (isInParentTree(curState, nextState) == false)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_enterState);
        INFO_ENTER_STATE(nextState);

        switch (nextState)
        {
        case TrafficLightFSM::eState::TRAFIC_LIGHT_OFF:
            INFO_ACTION_ENTER("actionPowerOff");
            mActionHandler.actionPowerOff();
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_ON:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_INITIALIZE:
            INFO_ACTION_ENTER("actionPowerOn");
            mActionHandler.actionPowerOn();
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_FUNCTION:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW:
            INFO_ACTION_ENTER("actionVehicleYellow");
            mActionHandler.actionVehicleYellow();
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_RED:
            if (mTimerRed.isActive() == false)
            {
                TRACE_DBG("Starting non active timer Red with 10000 ms of timeout and 1 numbers of repeats."); 
                mTimerRed.startTimer(10000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer Red with 10000 ms of timeout and 1 numbers of repeats."); 
            }
            INFO_ACTION_ENTER("actionVehicleRed");
            mActionHandler.actionVehicleRed();
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_VEHICLE_RED:
            if (mTimerVehicleWait.isActive() == false)
            {
                TRACE_DBG("Starting non active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
                mTimerVehicleWait.startTimer(1000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
            }

            if (mTimerPedestrianWalk.isActive() == false)
            {
                TRACE_DBG("Starting non active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
                mTimerPedestrianWalk.startTimer(5000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
            }

            INFO_ACTION_ENTER("actionPedestrianGreen");
            mActionHandler.actionPedestrianGreen(true);
            break;

        case TrafficLightFSM::eState::OPPOSIT_PEDESTRIAN_GREEN:
            INFO_ACTION_ENTER("actionVehicleGreen");
            mActionHandler.actionVehicleGreen(true);
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_GREEN:
            if (mTimerGreen.isActive() == false)
            {
                TRACE_DBG("Starting non active timer Green with 10000 ms of timeout and 1 numbers of repeats."); 
                mTimerGreen.startTimer(10000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer Green with 10000 ms of timeout and 1 numbers of repeats."); 
            }
            break;

        case TrafficLightFSM::eState::TRAFFIC_PEDESTRIAN_GREEN:
            if (mTimerVehicleWait.isActive() == false)
            {
                TRACE_DBG("Starting non active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
                mTimerVehicleWait.startTimer(1000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
            }

            if (mTimerPedestrianWalk.isActive() == false)
            {
                TRACE_DBG("Starting non active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
                mTimerPedestrianWalk.startTimer(5000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
            }

            INFO_ACTION_ENTER("actionPedestrianGreen");
            mActionHandler.actionPedestrianGreen(false);
            break;

        case TrafficLightFSM::eState::TRAFFIC_VEHICLE_GREEN:
            INFO_ACTION_ENTER("actionVehicleGreen");
            mActionHandler.actionVehicleGreen(false);
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_START:
            sendEvent(NETrafficLightFSM::eFsmEventData::EVENT_StartTrafficLight);
            break;

        case TrafficLightFSM::eState::UNDEFINED:  // fall through
        case TrafficLightFSM::eState::STATE_SIZE: // fall through
        default:
            TRACE_ERR("FSM < %s >: Unexpected State Machine State!", mFsmName.getString());
            ASSERT(false);
        }

        TrafficLightFSM::eState child = sChildStates[static_cast<int>(nextState)];
        if (child != TrafficLightFSM::eState::UNDEFINED)
        {
            enterState(curState, child, nameTrigger);
        }
        else
        {
            updateStateTree(curState,  TrafficLightFSM::eState::UNDEFINED);
            updateStateTree(nextState, nextState);

            INFO_GO_STATE(mState, nextState);

            mState = nextState;
        }
    }
}

/**
 * Call to exit state and trigger actions on exit
 **/
inline void TrafficLightFSM::leaveState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger )
{
    if (isInParentTree(curState, nextState) == false)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_leaveState);
        switch (curState)
        {
        case TrafficLightFSM::eState::TRAFIC_LIGHT_OFF:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_ON:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_INITIALIZE:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_FUNCTION:
            TRACE_DBG("Stopping timer Red, which current status is [ %s ].", mTimerRed.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerRed.stopTimer( );
            
            TRACE_DBG("Stopping timer YellowRed, which current status is [ %s ].", mTimerYellowRed.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerYellowRed.stopTimer( );
            
            TRACE_DBG("Stopping timer Green, which current status is [ %s ].", mTimerGreen.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerGreen.stopTimer( );

            TRACE_DBG("Stopping timer YellowGreen, which current status is [ %s ].", mTimerYellowGreen.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerYellowGreen.stopTimer( );
            
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_RED:
            TRACE_DBG("Stopping timer PedestrianWalk, which current status is [ %s ].", mTimerPedestrianWalk.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerPedestrianWalk.stopTimer( );
            
            TRACE_DBG("Stopping timer VehicleWait, which current status is [ %s ].", mTimerVehicleWait.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerVehicleWait.stopTimer( );
            
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_VEHICLE_RED:
            break;

        case TrafficLightFSM::eState::OPPOSIT_PEDESTRIAN_GREEN:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_GREEN:
            TRACE_DBG("Stopping timer PedestrianWalk, which current status is [ %s ].", mTimerPedestrianWalk.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerPedestrianWalk.stopTimer( );
            TRACE_DBG("Stopping timer VehicleWait, which current status is [ %s ].", mTimerVehicleWait.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerVehicleWait.stopTimer( );
            INFO_ACTION_EXIT("actionPedestrianRed");
            mActionHandler.actionPedestrianRed();
            break;

        case TrafficLightFSM::eState::TRAFFIC_PEDESTRIAN_GREEN:
            break;

        case TrafficLightFSM::eState::TRAFFIC_VEHICLE_GREEN:
            break;

        case TrafficLightFSM::eState::TRAFFIC_LIGHT_START:
            break;

        case    TrafficLightFSM::eState::UNDEFINED:  // fall through
        case    TrafficLightFSM::eState::STATE_SIZE: // fall through
        default:
            TRACE_ERR("FSM < %s >: Unexpected State Machine State!", mFsmName.getString());
            ASSERT(false);
        }

        INFO_EXIT_STATE(curState);

        TrafficLightFSM::eState parent   = sParrentStates[static_cast<int>(curState)];
        if (parent != TrafficLightFSM::eState::UNDEFINED && isInParentTree(nextState, parent) == false)
        {
            leaveState(parent, nextState, nameTrigger);
        }
    }
}

/**
 * Call to initialize State Machine. Initialize before calling any trigger.
 **/
void TrafficLightFSM::initFSM( DispatcherThread * ownerThread /*= nullptr*/ )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_initFSM);
    if (mState != TrafficLightFSM::eState::UNDEFINED)
    {
        TRACE_ERR("FSM < %s >: The initialization of state machine must be done on startup only!", mFsmName.getString());
        ASSERT(false);
    }

    mMasterThread   = ownerThread != nullptr ? ownerThread : &(DispatcherThread::getCurrentDispatcherThread( ));
    NETrafficLightFSM::FsmEvent::addListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(mEventConsumer), *mMasterThread );
    
    mCurrentStates[static_cast<int>(eState::UNDEFINED)] = TrafficLightFSM::eState::UNDEFINED;
   
    mCurrentStates[static_cast<int>(eState::TRAFIC_LIGHT_OFF)]          = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_ON)]          = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_INITIALIZE)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_FUNCTION)]    = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_YELLOW)]      = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_RED)]         = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_VEHICLE_RED)] = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::OPPOSIT_PEDESTRIAN_GREEN)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_GREEN)]       = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_PEDESTRIAN_GREEN)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_VEHICLE_GREEN)]     = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_START)]       = TrafficLightFSM::eState::UNDEFINED;

    enterState(TrafficLightFSM::eState::UNDEFINED, TrafficLightFSM::eState::TRAFIC_LIGHT_OFF, "initFSM");
}

/**
 * Call to release State Machine. No trigger will be processed
 **/
void TrafficLightFSM::releaseFSM( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_releaseFSM);
    TRACE_DBG("Releasing < %s > State Machine. Initialize before calling triggers.", mFsmName.getString());

    if ( mMasterThread != nullptr )
    {
        NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(mEventConsumer), *mMasterThread );
    }
    else
    {
        NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(mEventConsumer) );
    }

    mState          = TrafficLightFSM::eState::UNDEFINED;
    mMasterThread   = nullptr;

    mTimerRed.stopTimer( );
    mTimerYellowRed.stopTimer( );
    mTimerGreen.stopTimer( );
    mTimerYellowGreen.stopTimer( );
    mTimerPedestrianWalk.stopTimer( );
    mTimerVehicleWait.stopTimer( );

    mCurrentStates[static_cast<int>(eState::UNDEFINED)] = TrafficLightFSM::eState::UNDEFINED;
   
    mCurrentStates[static_cast<int>(eState::TRAFIC_LIGHT_OFF)]          = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_ON)]          = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_INITIALIZE)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_FUNCTION)]    = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_YELLOW)]      = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_RED)]         = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_VEHICLE_RED)] = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::OPPOSIT_PEDESTRIAN_GREEN)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_GREEN)]       = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_PEDESTRIAN_GREEN)]  = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_VEHICLE_GREEN)]     = TrafficLightFSM::eState::UNDEFINED;
    mCurrentStates[static_cast<int>(eState::TRAFFIC_LIGHT_START)]       = TrafficLightFSM::eState::UNDEFINED;
}


/**
 * Triggered to power off the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOff);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::powerOff( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOff);
    START_PROCESSING( "powerOff" );

    if ( isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_ON) == true )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFIC_LIGHT_OFF;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to power on the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOn);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::powerOn( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOn);
    START_PROCESSING( "powerOn" );

    if ( mState == TrafficLightFSM::eState::TRAFIC_LIGHT_OFF )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_ON;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to start controlling the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_startTrafficControl);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::startTrafficControl( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_startTrafficControl);
    START_PROCESSING( "startTrafficControl" );

    if ( mState == TrafficLightFSM::eState::TRAFFIC_LIGHT_INITIALIZE )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_FUNCTION;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);

        if (mTimerYellowGreen.isActive() == false)
        {
            TRACE_DBG("Starting non active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
            mTimerYellowGreen.startTimer(3000, 1);
        }
        else
        {
            TRACE_WARN("Ignoring start active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
        }

        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to stop the traffic light controller.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_stopTrafficControl);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::stopTrafficControl( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_stopTrafficControl);
    START_PROCESSING( "stopTrafficControl" );

    if ( isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_FUNCTION) == true )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_INITIALIZE;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}


/**
 * Triggered on event 'StartTrafficLight'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onEventStartTrafficLight);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onEventStartTrafficLight( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onEventStartTrafficLight);
    START_PROCESSING("Event_StartTrafficLight");

    if ( mState == TrafficLightFSM::eState::TRAFFIC_LIGHT_START )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'Red'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerRed);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerRed( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerRed);
    START_PROCESSING("Timer_Red");

    if (isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_RED))
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);

        if (mTimerYellowGreen.isActive() == false)
        {
            TRACE_DBG("Starting non active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
            mTimerYellowGreen.startTimer(3000, 1);
        }
        else
        {
            TRACE_WARN("Ignoring start active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
        }

        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'YellowRed'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowRed);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerYellowRed( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowRed);
    START_PROCESSING("Timer_YellowRed");

    if ( mState == TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_RED;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'Green'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerGreen);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerGreen( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerGreen);
    START_PROCESSING("Timer_Green");

    if (isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_GREEN) == true)
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
            if (mTimerYellowRed.isActive() == false)
            {
                TRACE_DBG("Starting non active timer YellowRed with 3000 ms of timeout and 1 numbers of repeats."); 
                mTimerYellowRed.startTimer(3000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer YellowRed with 3000 ms of timeout and 1 numbers of repeats."); 
            }
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'YellowGreen'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowGreen);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerYellowGreen( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowGreen);
    START_PROCESSING("Timer_YellowGreen");

    if ( mState == TrafficLightFSM::eState::TRAFFIC_LIGHT_YELLOW )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_LIGHT_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'PedestrianWalk'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerPedestrianWalk);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerPedestrianWalk( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerPedestrianWalk);
    START_PROCESSING("Timer_PedestrianWalk");

    if (isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_GREEN) == true)
    {
        INFO_ACTION_SWITCH("actionPedestrianRed");
        mActionHandler.actionPedestrianRed();
        INFO_PROCESSED_SAME(mState);

        break;
    }

    if (isInParentTree(mState, TrafficLightFSM::eState::TRAFFIC_LIGHT_RED) == true)
    {
        INFO_ACTION_SWITCH("actionPedestrianRed");
        mActionHandler.actionPedestrianRed();
        INFO_PROCESSED_SAME(mState);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'VehicleWait'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerVehicleWait);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerVehicleWait( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerVehicleWait);
    START_PROCESSING("Timer_VehicleWait");

    if ( mState == TrafficLightFSM::eState::TRAFFIC_LIGHT_VEHICLE_RED )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::OPPOSIT_PEDESTRIAN_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    if ( mState == TrafficLightFSM::eState::TRAFFIC_PEDESTRIAN_GREEN )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::eState::TRAFFIC_VEHICLE_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

////////////////////////////////////////////////////////////////////////////////
// End generate TrafficLightFSM.cpp file
////////////////////////////////////////////////////////////////////////////////
