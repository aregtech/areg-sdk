
//////////////////////////////////////////////////////////////////////////
// Begin generate TrafficLightFSM.cpp file
//////////////////////////////////////////////////////////////////////////

/************************************************************************
 * (c) copyright    2021
 *                  Generated by AREGtech code generator tool.
 * Generated at     15.08.2021  12:23:44 GMT+02:00 
 ************************************************************************/

/************************************************************************
 * \file            generated/src/private/TrafficLightFSM.cpp
 * \ingroup         TrafficLight State Machine
 * \brief           This is an automatic generated code of TrafficLight 
 *                  State Machine class implementation.
 *                  Do not make changes in the file
 ************************************************************************/

/************************************************************************
 * Include files
 ************************************************************************/
#include "generated/src/private/TrafficLightFSM.hpp"

#include "generated/src/private/IETrafficLightActionHandler.hpp"
#include "areg/component/DispatcherThread.hpp"
#include "areg/trace/GETrace.h"

//////////////////////////////////////////////////////////////////////////
// use of namespace to access defined types directly
//////////////////////////////////////////////////////////////////////////
using namespace NETrafficLightFSM;


//////////////////////////////////////////////////////////////////////////
// Predefined local Macro
//////////////////////////////////////////////////////////////////////////

#define  INFO_PROCESSED(curr, next)         \
    TRACE_DBG("FSM < %s >: The trigger < %s > was processed to switch from state < %s > ==> to state < %s >.", mInstanceName, nameTrigger, getString(curr), getString(next))

#define  INFO_PROCESSED_SAME(state)          \
    TRACE_DBG("FSM < %s >: The trigger < %s > was processed in state < %s >.", mInstanceName, nameTrigger, getString(state))

#define  INFO_NOT_PROCESSED                  \
    TRACE_DBG("FSM < %s >: The trigger < %s > was not processed in state < %s >.", mInstanceName, nameTrigger, getString(mState))

#define  INFO_ACTION_SWITCH(actionName)      \
    TRACE_DBG("FSM < %s >: Processing action < %s > on trigger < %s >.", mInstanceName, (actionName), nameTrigger)

#define  INFO_ACTION_ENTER(actionName)       \
    TRACE_DBG("FSM < %s >: Processing action < %s > entering state < %s >.", mInstanceName, (actionName), getString(nextState))

#define  INFO_ACTION_EXIT(actionName)        \
    TRACE_DBG("FSM < %s >: Processing action < %s > exiting state < %s >.", mInstanceName, (actionName), getString(curState))

#define  INFO_ENTER_STATE(enterState)        \
    TRACE_DBG("FSM < %s >: Entering state ==> < %s >.", mInstanceName, getString(enterState))

#define  INFO_EXIT_STATE(exitState)          \
    TRACE_DBG("FSM < %s >: Leaving state: < %s >.", mInstanceName, getString(exitState))

#define  INFO_GO_STATE(fromState, toState)  \
     TRACE_DBG("FSM < %s >: Switched state: < %s > ==> < %s >.", mInstanceName, getString(fromState), getString(toState))

#define  START_PROCESSING( triggerName )                        \
    bool    isProcessed = false;                                \
    const char* nameTrigger = triggerName;                      \
    if (startProcessing(nameTrigger) == true)                   \
    {                                                           \
        isProcessed = true;                                     \
        do                                                      \
        {


#define  END_PROCESSING( )                                      \
            isProcessed = false;                                \
            INFO_NOT_PROCESSED;                                 \
        } while (false);                                        \
      endProcessing();                                          \
    }                                                           \
    return isProcessed;                         

////////////////////////////////////////////////////////////////////////////////
// Trace scope declaration 
////////////////////////////////////////////////////////////////////////////////
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_initFSM);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_releaseFSM);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_enterState);
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_leaveState);

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM Class Implementation 
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM predefined static members 
////////////////////////////////////////////////////////////////////////////////

/**
 * Parent state array
 **/
const TrafficLightFSM::eState  TrafficLightFSM::sParrentStates[] =  
{
    /* UNDEFINED                 */   TrafficLightFSM::UNDEFINED

    /* TRAFIC_LIGHT_OFF          */ , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_ON          */ , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_INITIALIZE  */ , TrafficLightFSM::TRAFFIC_LIGHT_ON
    /* TRAFFIC_LIGHT_FUNCTION    */ , TrafficLightFSM::TRAFFIC_LIGHT_ON
    /* TRAFFIC_LIGHT_YELLOW      */ , TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION
    /* TRAFFIC_LIGHT_RED         */ , TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION
    /* TRAFFIC_LIGHT_VEHICLE_RED */ , TrafficLightFSM::TRAFFIC_LIGHT_RED
    /* OPPOSIT_PEDESTRIAN_GREEN  */ , TrafficLightFSM::TRAFFIC_LIGHT_RED
    /* TRAFFIC_LIGHT_GREEN       */ , TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION
    /* TRAFFIC_PEDESTRIAN_GREEN  */ , TrafficLightFSM::TRAFFIC_LIGHT_GREEN
    /* TRAFFIC_VEHICLE_GREEN     */ , TrafficLightFSM::TRAFFIC_LIGHT_GREEN
    /* TRAFFIC_LIGHT_START       */ , TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION   
};

/**
 * Direct child array
 **/
const TrafficLightFSM::eState  TrafficLightFSM::sChildStates[] = 
{
    /* UNDEFINED                    */     TrafficLightFSM::UNDEFINED

    /* TRAFIC_LIGHT_OFF             */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_ON             */   , TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE
    /* TRAFFIC_LIGHT_INITIALIZE     */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_FUNCTION       */   , TrafficLightFSM::TRAFFIC_LIGHT_START
    /* TRAFFIC_LIGHT_YELLOW         */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_RED            */   , TrafficLightFSM::TRAFFIC_LIGHT_VEHICLE_RED
    /* TRAFFIC_LIGHT_VEHICLE_RED    */   , TrafficLightFSM::UNDEFINED
    /* OPPOSIT_PEDESTRIAN_GREEN     */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_GREEN          */   , TrafficLightFSM::TRAFFIC_PEDESTRIAN_GREEN
    /* TRAFFIC_PEDESTRIAN_GREEN     */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_VEHICLE_GREEN        */   , TrafficLightFSM::UNDEFINED
    /* TRAFFIC_LIGHT_START          */   , TrafficLightFSM::UNDEFINED
};

////////////////////////////////////////////////////////////////////////////////
// TrafficLightFSM Class constructor / destructor 
////////////////////////////////////////////////////////////////////////////////
TrafficLightFSM::TrafficLightFSM( IETrafficLightActionHandler & actionHandler, const char* const instanceName /* = NETrafficLightFSM::InstanceDefaultName */ )
    : IETimerConsumer( )
    , NETrafficLightFSM::IEFsmEventConsumer( )
    , mActionHandler  ( actionHandler )
    
    , mTimerRed( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::Red" )
    , mTimerYellowRed( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::YellowRed" )
    , mTimerGreen( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::Green" )
    , mTimerYellowGreen( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::YellowGreen" )
    , mTimerPedestrianWalk( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::PedestrianWalk" )
    , mTimerVehicleWait( static_cast< IETimerConsumer &>(self()) , "TrafficLightFsm::VehicleWait" )
    

    , mFsmName      ( String("TrafficLightFSM:") + (instanceName != nullptr ? instanceName : "") )
    , mInstanceName ( mFsmName.getString() )
    , mMasterThread ( nullptr )
    , mProcessing   ( false )
    , mState        ( TrafficLightFSM::UNDEFINED )    
{
    mCurrentStates[UNDEFINED]                 = TrafficLightFSM::UNDEFINED;
   
    mCurrentStates[TRAFIC_LIGHT_OFF]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_ON]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_INITIALIZE]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_FUNCTION]    = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_YELLOW]      = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_RED]         = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_VEHICLE_RED] = TrafficLightFSM::UNDEFINED;
    mCurrentStates[OPPOSIT_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_GREEN]       = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_VEHICLE_GREEN]     = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_START]       = TrafficLightFSM::UNDEFINED;
}

TrafficLightFSM::~TrafficLightFSM( void )
{
    NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()) );
}

/**
 * Start processing trigger
 **/
inline bool TrafficLightFSM::startProcessing( const char* const triggerName )
{
    bool result = false;
    if (mState == TrafficLightFSM::UNDEFINED)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
        TRACE_ERR("FSM < %s >: The State Machine is not initialized to call trigger < %s >!", mInstanceName, triggerName);
        ASSERT(false);
    }
    else if (mProcessing == true)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_startProcessing);
        TRACE_ERR("FSM < %s >: Invalid trigger < %s > call during processing action!", mInstanceName, triggerName);
        ASSERT(false);
    }
    else
    {
        mProcessing = true;
        result      = true;
    }
    return result;
}

/**
 * End processing trigger
 **/
inline void TrafficLightFSM::endProcessing( void )
{
    mProcessing = false;
}

/**
 * Update state tree
 **/
inline void TrafficLightFSM::updateStateTree( const TrafficLightFSM::eState whichState, const TrafficLightFSM::eState curState )
{
    ASSERT(curState   != TrafficLightFSM::STATE_SIZE);

    TrafficLightFSM::eState parent = sParrentStates[static_cast<int>(whichState)];
    if (parent != TrafficLightFSM::UNDEFINED)
        updateStateTree(parent, curState);
    mCurrentStates[whichState] = curState;
}

/**
 * Checks if the state is in parent tree
 **/
inline bool TrafficLightFSM::isInParentTree( TrafficLightFSM::eState whichState, const TrafficLightFSM::eState checkState )
{
    ASSERT(checkState != TrafficLightFSM::UNDEFINED && checkState != TrafficLightFSM::STATE_SIZE);

    bool result = whichState == checkState;
    if (result == false)
    {
        whichState  = sParrentStates[static_cast<int>(whichState)];
        result      = whichState != TrafficLightFSM::UNDEFINED ? isInParentTree(whichState, checkState) : false;
    }
    return result;
}

/**
 * Call to enter state and trigger actions on enter
 **/
inline void TrafficLightFSM::enterState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger )
{
    if (isInParentTree(curState, nextState) == false)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_enterState);
        INFO_ENTER_STATE(nextState);

        switch (nextState)
        {
        case TrafficLightFSM::TRAFIC_LIGHT_OFF:
            INFO_ACTION_ENTER("actionPowerOff");
            mActionHandler.actionPowerOff();
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_ON:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE:
            INFO_ACTION_ENTER("actionPowerOn");
            mActionHandler.actionPowerOn();
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_YELLOW:
            INFO_ACTION_ENTER("actionVehicleYellow");
            mActionHandler.actionVehicleYellow();
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_RED:
            if (mTimerRed.isActive() == false)
            {
                TRACE_DBG("Starting non active timer Red with 10000 ms of timeout and 1 numbers of repeats."); 
                mTimerRed.startTimer(10000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer Red with 10000 ms of timeout and 1 numbers of repeats."); 
            }
            INFO_ACTION_ENTER("actionVehicleRed");
            mActionHandler.actionVehicleRed();
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_VEHICLE_RED:
            if (mTimerVehicleWait.isActive() == false)
            {
                TRACE_DBG("Starting non active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
                mTimerVehicleWait.startTimer(1000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
            }
            if (mTimerPedestrianWalk.isActive() == false)
            {
                TRACE_DBG("Starting non active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
                mTimerPedestrianWalk.startTimer(5000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
            }
            INFO_ACTION_ENTER("actionPedestrianGreen");
            mActionHandler.actionPedestrianGreen(true);
            break;

        case TrafficLightFSM::OPPOSIT_PEDESTRIAN_GREEN:
            INFO_ACTION_ENTER("actionVehicleGreen");
            mActionHandler.actionVehicleGreen(true);
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_GREEN:
            if (mTimerGreen.isActive() == false)
            {
                TRACE_DBG("Starting non active timer Green with 10000 ms of timeout and 1 numbers of repeats."); 
                mTimerGreen.startTimer(10000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer Green with 10000 ms of timeout and 1 numbers of repeats."); 
            }
            break;

        case TrafficLightFSM::TRAFFIC_PEDESTRIAN_GREEN:
            if (mTimerVehicleWait.isActive() == false)
            {
                TRACE_DBG("Starting non active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
                mTimerVehicleWait.startTimer(1000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer VehicleWait with 1000 ms of timeout and 1 numbers of repeats."); 
            }
            if (mTimerPedestrianWalk.isActive() == false)
            {
                TRACE_DBG("Starting non active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
                mTimerPedestrianWalk.startTimer(5000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer PedestrianWalk with 5000 ms of timeout and 1 numbers of repeats."); 
            }
            INFO_ACTION_ENTER("actionPedestrianGreen");
            mActionHandler.actionPedestrianGreen(false);
            break;

        case TrafficLightFSM::TRAFFIC_VEHICLE_GREEN:
            INFO_ACTION_ENTER("actionVehicleGreen");
            mActionHandler.actionVehicleGreen(false);
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_START:
            sendEvent(NETrafficLightFSM::EVENT_StartTrafficLight);
            break;

        case TrafficLightFSM::UNDEFINED:  // fall through
        case TrafficLightFSM::STATE_SIZE: // fall through
        default:
            TRACE_ERR("FSM < %s >: Unexpected State Machine State!", mInstanceName);
            ASSERT(false);
        }

        TrafficLightFSM::eState child = sChildStates[static_cast<int>(nextState)];
        if (child != TrafficLightFSM::UNDEFINED)
        {
            enterState(curState, child, nameTrigger);
        }
        else
        {
            updateStateTree(curState,  TrafficLightFSM::UNDEFINED);
            updateStateTree(nextState, nextState);

            INFO_GO_STATE(mState, nextState);

            mState = nextState;
        }
    }
}

/**
 * Call to exit state and trigger actions on exit
 **/
inline void TrafficLightFSM::leaveState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger )
{
    if (isInParentTree(curState, nextState) == false)
    {
        TRACE_SCOPE(generated_src_private_TrafficLightFSM_leaveState);
        switch (curState)
        {
        case TrafficLightFSM::TRAFIC_LIGHT_OFF:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_ON:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION:
            TRACE_DBG("Stopping timer Red, which current status is [ %s ].", mTimerRed.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerRed.stopTimer( );
            TRACE_DBG("Stopping timer YellowRed, which current status is [ %s ].", mTimerYellowRed.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerYellowRed.stopTimer( );
            TRACE_DBG("Stopping timer Green, which current status is [ %s ].", mTimerGreen.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerGreen.stopTimer( );
            TRACE_DBG("Stopping timer YellowGreen, which current status is [ %s ].", mTimerYellowGreen.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerYellowGreen.stopTimer( );
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_YELLOW:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_RED:
            TRACE_DBG("Stopping timer PedestrianWalk, which current status is [ %s ].", mTimerPedestrianWalk.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerPedestrianWalk.stopTimer( );
            TRACE_DBG("Stopping timer VehicleWait, which current status is [ %s ].", mTimerVehicleWait.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerVehicleWait.stopTimer( );
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_VEHICLE_RED:
            break;

        case TrafficLightFSM::OPPOSIT_PEDESTRIAN_GREEN:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_GREEN:
            TRACE_DBG("Stopping timer PedestrianWalk, which current status is [ %s ].", mTimerPedestrianWalk.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerPedestrianWalk.stopTimer( );
            TRACE_DBG("Stopping timer VehicleWait, which current status is [ %s ].", mTimerVehicleWait.isActive() == true ? "ACTIVE" : "NOT ACTIVE");
            mTimerVehicleWait.stopTimer( );
            INFO_ACTION_EXIT("actionPedestrianRed");
            mActionHandler.actionPedestrianRed();
            break;

        case TrafficLightFSM::TRAFFIC_PEDESTRIAN_GREEN:
            break;

        case TrafficLightFSM::TRAFFIC_VEHICLE_GREEN:
            break;

        case TrafficLightFSM::TRAFFIC_LIGHT_START:
            break;

        case    TrafficLightFSM::UNDEFINED:  // fall through
        case    TrafficLightFSM::STATE_SIZE: // fall through
        default:
            TRACE_ERR("FSM < %s >: Unexpected State Machine State!", mInstanceName);
            ASSERT(false);
        }

        INFO_EXIT_STATE(curState);

        TrafficLightFSM::eState parent   = sParrentStates[static_cast<int>(curState)];
        if (parent != TrafficLightFSM::UNDEFINED && isInParentTree(nextState, parent) == false)
            leaveState(parent, nextState, nameTrigger);
    }
}

/**
 * Call to initialize State Machine. Initialize before calling any trigger.
 **/
void TrafficLightFSM::initFSM( DispatcherThread * masterThread /*= nullptr*/ )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_initFSM);
    if (mState != TrafficLightFSM::UNDEFINED)
    {
        TRACE_ERR("FSM < %s >: The initialization of state machine must be done on startup only!", mInstanceName);
        ASSERT(false);
    }

    mMasterThread   = masterThread != nullptr ? masterThread : &(DispatcherThread::getCurrentDispatcherThread( ));
    NETrafficLightFSM::FsmEvent::addListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()), *mMasterThread );
    
    mCurrentStates[UNDEFINED]                 = TrafficLightFSM::UNDEFINED;
   
    mCurrentStates[TRAFIC_LIGHT_OFF]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_ON]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_INITIALIZE]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_FUNCTION]    = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_YELLOW]      = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_RED]         = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_VEHICLE_RED] = TrafficLightFSM::UNDEFINED;
    mCurrentStates[OPPOSIT_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_GREEN]       = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_VEHICLE_GREEN]     = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_START]       = TrafficLightFSM::UNDEFINED;

    enterState(TrafficLightFSM::UNDEFINED, TrafficLightFSM::TRAFIC_LIGHT_OFF, "initFSM");
}

/**
 * Call to release State Machine. No trigger will be processed
 **/
void TrafficLightFSM::releaseFSM( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_releaseFSM);
    TRACE_DBG("Releasing < %s > State Machine. Initialize before calling triggers.", mInstanceName != nullptr ? mInstanceName : "");

    if ( mMasterThread != nullptr )
        NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()), *mMasterThread );
    else
        NETrafficLightFSM::FsmEvent::removeListener( static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()) );
 
    mState          = TrafficLightFSM::UNDEFINED;
    mMasterThread   = nullptr;

    mTimerRed.stopTimer( );
    mTimerYellowRed.stopTimer( );
    mTimerGreen.stopTimer( );
    mTimerYellowGreen.stopTimer( );
    mTimerPedestrianWalk.stopTimer( );
    mTimerVehicleWait.stopTimer( );

    mCurrentStates[UNDEFINED]                 = TrafficLightFSM::UNDEFINED;
   
    mCurrentStates[TRAFIC_LIGHT_OFF]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_ON]          = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_INITIALIZE]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_FUNCTION]    = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_YELLOW]      = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_RED]         = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_VEHICLE_RED] = TrafficLightFSM::UNDEFINED;
    mCurrentStates[OPPOSIT_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_GREEN]       = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_PEDESTRIAN_GREEN]  = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_VEHICLE_GREEN]     = TrafficLightFSM::UNDEFINED;
    mCurrentStates[TRAFFIC_LIGHT_START]       = TrafficLightFSM::UNDEFINED;
}


/**
 * Triggered to power off the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOff);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::powerOff( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOff);
    START_PROCESSING( "powerOff" );

    if ( isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_ON) == true )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFIC_LIGHT_OFF;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to power on the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOn);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::powerOn( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_powerOn);
    START_PROCESSING( "powerOn" );

    if ( mState == TrafficLightFSM::TRAFIC_LIGHT_OFF )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_ON;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to start controlling the traffic light.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_startTrafficControl);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::startTrafficControl( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_startTrafficControl);
    START_PROCESSING( "startTrafficControl" );

    if ( mState == TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
            if (mTimerYellowGreen.isActive() == false)
            {
                TRACE_DBG("Starting non active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
                mTimerYellowGreen.startTimer(3000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
            }
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * Triggered to stop the traffic light controller.
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_stopTrafficControl);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::stopTrafficControl( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_stopTrafficControl);
    START_PROCESSING( "stopTrafficControl" );

    if ( isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION) == true )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED( curr, next );

        break;
    }

    END_PROCESSING( );
}

/**
 * \brief   Called to process events
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_processEvent);
/* --------------------------------------------------------------------- */
void TrafficLightFSM::processEvent( const NETrafficLightFSM::FsmEventData & data )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_processEvent);
    if ( mState != TrafficLightFSM::UNDEFINED )
    {
        TRACE_DBG("Processing event < %s >.", NETrafficLightFSM::getString(data.mEventValue));
       
        switch ( data.mEventValue )
        {
        case NETrafficLightFSM::EVENT_StartTrafficLight:
            onEventStartTrafficLight();
            break;

        default:
            TRACE_ERR("Unknown Event was requested to be processed!");
            ASSERT(false);
            break;   // do nothing
        }
    }
    else
    {
        TRACE_WARN("Ignoring event < %s >, the state machine < %s > is not initialized.", NETrafficLightFSM::getString(data.mEventValue), mInstanceName != nullptr ? mInstanceName : "");
    }
}


/**
 * Triggered on event 'StartTrafficLight'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onEventStartTrafficLight);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onEventStartTrafficLight( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onEventStartTrafficLight);
    START_PROCESSING("Event_StartTrafficLight");

    if ( mState == TrafficLightFSM::TRAFFIC_LIGHT_START )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}


/**
 * Called to process expired timers
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_ProcessTimer);
/* --------------------------------------------------------------------- */
void TrafficLightFSM::processTimer( Timer & timer )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_ProcessTimer);    
    TRACE_DBG("Processing Timer < %s >.", timer.getName().getString());
    
    do
    {
        if (timer.isStopped() == false)
        {
            if ( &timer == &mTimerRed )
            {
                onTimerRed( );
                break;
            }
            if ( &timer == &mTimerYellowRed )
            {
                onTimerYellowRed( );
                break;
            }
            if ( &timer == &mTimerGreen )
            {
                onTimerGreen( );
                break;
            }
            if ( &timer == &mTimerYellowGreen )
            {
                onTimerYellowGreen( );
                break;
            }
            if ( &timer == &mTimerPedestrianWalk )
            {
                onTimerPedestrianWalk( );
                break;
            }
            if ( &timer == &mTimerVehicleWait )
            {
                onTimerVehicleWait( );
                break;
            }

            TRACE_ERR("Unknown timer was requested to be processed, none of existing timer has matched!");
            ASSERT(false);
        }
        else
        {
            TRACE_WARN("The timer [ %s ] is already stopped, ignoring processing timer.", timer.getName().getString());
        }
        
    } while (false);
}

/**
 * Triggered on timer 'Red'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerRed);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerRed( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerRed);
    START_PROCESSING("Timer_Red");

    if (isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_RED) == true)
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
            if (mTimerYellowGreen.isActive() == false)
            {
                TRACE_DBG("Starting non active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
                mTimerYellowGreen.startTimer(3000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer YellowGreen with 3000 ms of timeout and 1 numbers of repeats."); 
            }
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'YellowRed'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowRed);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerYellowRed( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowRed);
    START_PROCESSING("Timer_YellowRed");

    if ( mState == TrafficLightFSM::TRAFFIC_LIGHT_YELLOW )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_RED;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'Green'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerGreen);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerGreen( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerGreen);
    START_PROCESSING("Timer_Green");

    if (isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_GREEN) == true)
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_YELLOW;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
            if (mTimerYellowRed.isActive() == false)
            {
                TRACE_DBG("Starting non active timer YellowRed with 3000 ms of timeout and 1 numbers of repeats."); 
                mTimerYellowRed.startTimer(3000, 1);
            }
            else
            {
                TRACE_WARN("Ignoring start active timer YellowRed with 3000 ms of timeout and 1 numbers of repeats."); 
            }
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'YellowGreen'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowGreen);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerYellowGreen( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerYellowGreen);
    START_PROCESSING("Timer_YellowGreen");

    if ( mState == TrafficLightFSM::TRAFFIC_LIGHT_YELLOW )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_LIGHT_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'PedestrianWalk'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerPedestrianWalk);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerPedestrianWalk( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerPedestrianWalk);
    START_PROCESSING("Timer_PedestrianWalk");

    if (isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_GREEN) == true)
    {
        INFO_ACTION_SWITCH("actionPedestrianRed");
        mActionHandler.actionPedestrianRed();
        INFO_PROCESSED_SAME(mState);

        break;
    }

    if (isInParentTree(mState, TrafficLightFSM::TRAFFIC_LIGHT_RED) == true)
    {
        INFO_ACTION_SWITCH("actionPedestrianRed");
        mActionHandler.actionPedestrianRed();
        INFO_PROCESSED_SAME(mState);

        break;
    }

    END_PROCESSING();
}

/**
 * Triggered on timer 'VehicleWait'
 **/
/* --------------------------------------------------------------------- */
DEF_TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerVehicleWait);
/* --------------------------------------------------------------------- */
bool TrafficLightFSM::onTimerVehicleWait( void )
{
    TRACE_SCOPE(generated_src_private_TrafficLightFSM_onTimerVehicleWait);
    START_PROCESSING("Timer_VehicleWait");

    if ( mState == TrafficLightFSM::TRAFFIC_LIGHT_VEHICLE_RED )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::OPPOSIT_PEDESTRIAN_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    if ( mState == TrafficLightFSM::TRAFFIC_PEDESTRIAN_GREEN )
    {
        TrafficLightFSM::eState next  = TrafficLightFSM::TRAFFIC_VEHICLE_GREEN;
        TrafficLightFSM::eState curr  = mState;
        leaveState(curr, next, nameTrigger);
        enterState(curr, next, nameTrigger);  
        INFO_PROCESSED(curr, next);

        break;
    }

    END_PROCESSING();
}

////////////////////////////////////////////////////////////////////////////////
// End generate TrafficLightFSM.cpp file
////////////////////////////////////////////////////////////////////////////////
