
//////////////////////////////////////////////////////////////////////////
// Begin generate TrafficLightFSM.hpp file
//////////////////////////////////////////////////////////////////////////

#pragma once

/************************************************************************
 * (c) copyright    2021
 *                  Generated by AREGtech code generator tool.
 * Generated at     15.08.2021  12:23:44 GMT+02:00 
 ************************************************************************/

/**
 * \file       	    generated/src/private/TrafficLightFSM.hpp
 * \ingroup         TrafficLight State Machine
 * \brief      	    This is an automatic generated code of TrafficLight 
 *                  State Machine class declaration.
 *                  Do not make changes in the file.
 *
 *                  NOTE:   This class is generated as thread unsafe. 
 *                          No locking mechanism accessing methods or variables is provided.
 *
 **/

/************************************************************************
 * Include files
 ************************************************************************/
#include "generated/src/private/NETrafficLightFSM.hpp"

#include "areg/base/String.hpp"
#include "areg/component/Timer.hpp"
#include "areg/component/IETimerConsumer.hpp"

/************************************************************************
 * Dependencies
 ************************************************************************/
class IETrafficLightActionHandler;
class DispatcherThread;

//////////////////////////////////////////////////////////////////////////
// TrafficLightFSM class declaration 
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   TrafficLightFSM is a generated State Machine class.
 *          Instantiate by passing reference of action handler.
 *          The actions will be triggered depending on states.
 **/
class TrafficLightFSM :  protected IETimerConsumer, protected NETrafficLightFSM::IEFsmEventConsumer
{

//////////////////////////////////////////////////////////////////////////
// Predefined constants and types
//////////////////////////////////////////////////////////////////////////
private:
    /************************************************************************
     * \brief   TrafficLightFSM::eState
     *          The predefined states of TrafficLight State Machine.
     ************************************************************************/
    typedef  enum E_State
    {
          UNDEFINED

        , TRAFIC_LIGHT_OFF
        , TRAFFIC_LIGHT_ON
        , TRAFFIC_LIGHT_INITIALIZE
        , TRAFFIC_LIGHT_FUNCTION
        , TRAFFIC_LIGHT_YELLOW
        , TRAFFIC_LIGHT_RED
        , TRAFFIC_LIGHT_VEHICLE_RED
        , OPPOSIT_PEDESTRIAN_GREEN
        , TRAFFIC_LIGHT_GREEN
        , TRAFFIC_PEDESTRIAN_GREEN
        , TRAFFIC_VEHICLE_GREEN
        , TRAFFIC_LIGHT_START
   
        , STATE_SIZE

   } eState;
   
    /**
     * \brief   Returns the string value of TrafficLight states.
     * \param   state   The state value of TrafficLight State Machine.
     **/
    static inline const char* const getString( const TrafficLightFSM::eState & state );
    
//////////////////////////////////////////////////////////////////////////
// Constructor / Destructor
//////////////////////////////////////////////////////////////////////////
public:
    /**
     * \brief   Instantiates and initializes FSM internals
     * \param   actionHandler   The reference of action handler object to trigger actions.
     * \param   instanceName    The name of FSM instance. By default it has the name of FSM. 
     **/
    TrafficLightFSM( IETrafficLightActionHandler & actionHandler, const char* const instanceName = NETrafficLightFSM::InstanceDefaultName );

    /**
     * \brief   TrafficLightFSM class destructor
     **/
    ~TrafficLightFSM( void );

private:
    /**
     * \brief   Reference to State Machine action handler class object
     **/
    IETrafficLightActionHandler& mActionHandler;

public:

    /**
     * \brief   Initialize State Machine. Call before calling any trigger.
     * \param   ownerThread The pointer of master thread to process internal events and timers.
     **/
    void initFSM( DispatcherThread * ownerThread = nullptr );

    /**
     * \brief   Release State Machine. Call when complete working with FSM.
     **/
    void releaseFSM( void );

    /**
     * \brief   Call to send and event.
     * \param   fsmEventValue   The name of event, generated in NETrafficLightFSM namespace.
     **/
    inline void sendEvent( const NETrafficLightFSM::eFsmEventValue & eventValue );   

//////////////////////////////////////////////////////////////////////////
// TrafficLight State Machine Triggers
//////////////////////////////////////////////////////////////////////////
public:

    /**
     * \brief   Triggered to power off the traffic light.
     *
     * \return  Returns true if trigger was processed in the current state, otherwise it returns false.
     * \remark  The method is not thread safe.
     **/
    bool powerOff( void );

    /**
     * \brief   Triggered to power on the traffic light.
     *
     * \return  Returns true if trigger was processed in the current state, otherwise it returns false.
     * \remark  The method is not thread safe.
     **/
    bool powerOn( void );

    /**
     * \brief   Triggered to start controlling the traffic light.
     *
     * \return  Returns true if trigger was processed in the current state, otherwise it returns false.
     * \remark  The method is not thread safe.
     **/
    bool startTrafficControl( void );

    /**
     * \brief   Triggered to stop the traffic light controller.
     *
     * \return  Returns true if trigger was processed in the current state, otherwise it returns false.
     * \remark  The method is not thread safe.
     **/
    bool stopTrafficControl( void );

//////////////////////////////////////////////////////////////////////////
// Get / Set attributes
//////////////////////////////////////////////////////////////////////////
public:
//////////////////////////////////////////////////////////////////////////
// Timer functions
//////////////////////////////////////////////////////////////////////////
public:
/************************************************************************/
// Timer attributes
/************************************************************************/

    /**
     * \brief   Returns true if specified timer object is active
     **/
     inline const bool isTimerActive( const NETrafficLightFSM::eFsmTimerValue & whichTimer ) const;
protected:
/************************************************************************/
// Timer timer override methods
/************************************************************************/

    /**
     * \brief   Process State Machine timers
     * \remark  The method is not thread safe.
     **/
    virtual void processTimer( Timer & timer ) override;
    
private:
/************************************************************************/
// Timer Triggers
/************************************************************************/

    /**
     * \brief   Timer Red object
     **/
    Timer     mTimerRed;
    /**
     * \brief   Timer Red trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerRed( void );
    
    /**
     * \brief   Timer YellowRed object
     **/
    Timer     mTimerYellowRed;
    /**
     * \brief   Timer YellowRed trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerYellowRed( void );
    
    /**
     * \brief   Timer Green object
     **/
    Timer     mTimerGreen;
    /**
     * \brief   Timer Green trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerGreen( void );
    
    /**
     * \brief   Timer YellowGreen object
     **/
    Timer     mTimerYellowGreen;
    /**
     * \brief   Timer YellowGreen trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerYellowGreen( void );
    
    /**
     * \brief   Timer PedestrianWalk object
     **/
    Timer     mTimerPedestrianWalk;
    /**
     * \brief   Timer PedestrianWalk trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerPedestrianWalk( void );
    
    /**
     * \brief   Timer VehicleWait object
     **/
    Timer     mTimerVehicleWait;
    /**
     * \brief   Timer VehicleWait trigger
     * \return  Returns true if timer was processed in the current state. Otherwise it returns false.
     **/
    bool onTimerVehicleWait( void );
    
//////////////////////////////////////////////////////////////////////////
// Event functions
//////////////////////////////////////////////////////////////////////////
protected:
/************************************************************************/
// Event Consumer override
/************************************************************************/

    /**
     * \brief   Process State Machine events.
     * \param   data    The Event Data object passed to event when fired.
     * \remark  The method is not thread safe.
     **/
    virtual void processEvent( const NETrafficLightFSM::FsmEventData & data ) override;

private:
/************************************************************************/
// Event Triggers
/************************************************************************/

    /**
     * \brief   Event StartTrafficLight trigger
     * \return  Returns true if event was processed in the current state. Otherwise it returns false.
     **/
    bool onEventStartTrafficLight( void );

//////////////////////////////////////////////////////////////////////////
// Hidden internal processing methods and attributes
//////////////////////////////////////////////////////////////////////////
private:
    /**
     * \brief   Returns true if trigger can start processing. If a trigger called from processing action, this will return false.
     * \param   triggerName The string name of trigger to process
     **/
    bool startProcessing( const char* const triggerName );
    /**
     * \brief   Called when complete processing trigger
     **/
    void endProcessing( void );
    /**
     * \brief   Called when entering next state
     * \param   curState    Value of current state
     * \param   nextState   Value of next state to enter
     * \param   nameTrigger The string name of currently processing trigger
     **/
    void enterState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger );
    /**
     * \brief   Called when leaving current state
     * \param   curState    Value of current state
     * \param   nextState   Value of next state to enter
     * \param   nameTrigger The string name of currently processing trigger
     **/
    void leaveState( const TrafficLightFSM::eState curState, const TrafficLightFSM::eState nextState, const char* const nameTrigger );
    /**
     * \brief   Called when updating state tree
     * \param   whichState  The value of state to update, including child states
     * \param   curState    The value of current state
     **/
    void updateStateTree( const TrafficLightFSM::eState whichState, const TrafficLightFSM::eState curState );
    /**
     * \brief   Returns true if specified state is in parent tree, e.g. if current state is in child sub-state tree.
     * \param   whichState  The state for checking, usually current state.
     * \param   checkState  The state to check.
     **/
    bool isInParentTree( TrafficLightFSM::eState whichState, const TrafficLightFSM::eState checkState );

    /**
     * \brief   Returns the state machine object
     **/
    inline TrafficLightFSM& self( void );

//////////////////////////////////////////////////////////////////////////
// Standard internal member variables
//////////////////////////////////////////////////////////////////////////
private:
    
    /**
     * \brief   The name of State Machine
     **/
    const String                mFsmName;
    const char * const          mInstanceName;    
   
    /**
     * \brief   The master thread where event and timers should be processed. If nullptr, the current dispatcher value will be used
     **/
    DispatcherThread *          mMasterThread;
    /**
     * \brief   The flag, indicating whether State Machine is currently processing trigger or not.
     **/
    bool                        mProcessing;
    /**
     * \brief   The current state of State Machine
     **/
    eState                      mState;    
    /**
     * \brief   The array of state to indicate state changes. For parent state, this will indicate the current active child state
     **/
    eState                      mCurrentStates[STATE_SIZE];

//////////////////////////////////////////////////////////////////////////
// Static members. The tree structure of State Machine 
//////////////////////////////////////////////////////////////////////////
    /**
     * \brief   The fixed tree of parent states
     **/
   static const eState      sParrentStates[STATE_SIZE];
    /**
     * \brief   The fixed tree of child states
     **/
   static const eState      sChildStates[STATE_SIZE];
   
//////////////////////////////////////////////////////////////////////////
// Forbidden functions / methods call
//////////////////////////////////////////////////////////////////////////
private:
    TrafficLightFSM( void );
    TrafficLightFSM(const TrafficLightFSM & );
    const TrafficLightFSM& operator = (const TrafficLightFSM & );
};

//////////////////////////////////////////////////////////////////////////
// TrafficLightFSM class inline functions implementation
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Get / Set inline attributes
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// TrafficLightFSM class inline functions implementation
//////////////////////////////////////////////////////////////////////////
/**
 * \brief   Returns the state machine object
 **/
inline TrafficLightFSM& TrafficLightFSM::self( void )
{   return (*this); }

inline const bool TrafficLightFSM::isTimerActive( const NETrafficLightFSM::eFsmTimerValue & whichTimer ) const
{
    switch (whichTimer)
    {
    case NETrafficLightFSM::Red:
        return mTimerRed.isActive();
        
    case NETrafficLightFSM::YellowRed:
        return mTimerYellowRed.isActive();
        
    case NETrafficLightFSM::Green:
        return mTimerGreen.isActive();
        
    case NETrafficLightFSM::YellowGreen:
        return mTimerYellowGreen.isActive();
        
    case NETrafficLightFSM::PedestrianWalk:
        return mTimerPedestrianWalk.isActive();
        
    case NETrafficLightFSM::VehicleWait:
        return mTimerVehicleWait.isActive();
        
    default:
        ASSERT(false);  // wrong timer ID.
        return false;
    }
}
/**
 * \brief   Sends FSM event to be processed. By default the Event is external
 **/
inline void TrafficLightFSM::sendEvent( const NETrafficLightFSM::eFsmEventValue & eventValue )
{
    if (mMasterThread != nullptr )
        NETrafficLightFSM::FsmEvent::sendEvent(NETrafficLightFSM::FsmEventData( eventValue ), static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()), *mMasterThread);
    else
        NETrafficLightFSM::FsmEvent::sendEvent(NETrafficLightFSM::FsmEventData( eventValue ), static_cast<NETrafficLightFSM::IEFsmEventConsumer &>(self()));
}
/**
 * \brief   Returns the string value of states
 **/
inline  const char* const TrafficLightFSM::getString( const TrafficLightFSM::eState & state )
{
    switch (state)
    {
    case  UNDEFINED:
        return "TrafficLightFSM::UNDEFINED";

   case  TRAFIC_LIGHT_OFF:
      return "TrafficLightFSM::TRAFIC_LIGHT_OFF";

   case  TRAFFIC_LIGHT_ON:
      return "TrafficLightFSM::TRAFFIC_LIGHT_ON";

   case  TRAFFIC_LIGHT_INITIALIZE:
      return "TrafficLightFSM::TRAFFIC_LIGHT_INITIALIZE";

   case  TRAFFIC_LIGHT_FUNCTION:
      return "TrafficLightFSM::TRAFFIC_LIGHT_FUNCTION";

   case  TRAFFIC_LIGHT_YELLOW:
      return "TrafficLightFSM::TRAFFIC_LIGHT_YELLOW";

   case  TRAFFIC_LIGHT_RED:
      return "TrafficLightFSM::TRAFFIC_LIGHT_RED";

   case  TRAFFIC_LIGHT_VEHICLE_RED:
      return "TrafficLightFSM::TRAFFIC_LIGHT_VEHICLE_RED";

   case  OPPOSIT_PEDESTRIAN_GREEN:
      return "TrafficLightFSM::OPPOSIT_PEDESTRIAN_GREEN";

   case  TRAFFIC_LIGHT_GREEN:
      return "TrafficLightFSM::TRAFFIC_LIGHT_GREEN";

   case  TRAFFIC_PEDESTRIAN_GREEN:
      return "TrafficLightFSM::TRAFFIC_PEDESTRIAN_GREEN";

   case  TRAFFIC_VEHICLE_GREEN:
      return "TrafficLightFSM::TRAFFIC_VEHICLE_GREEN";

   case  TRAFFIC_LIGHT_START:
      return "TrafficLightFSM::TRAFFIC_LIGHT_START";

    case  STATE_SIZE: // fall through
    default:
        ASSERT(false);        
        return "ERR: Unexpected TrafficLightFSM::eState value!";

   }
}

//////////////////////////////////////////////////////////////////////////
// End generate TrafficLightFSM.hpp file
//////////////////////////////////////////////////////////////////////////
